var relearn_searchindex = [
  {
    "breadcrumb": "Ruoruoliu 2.0",
    "content": "This is a log.",
    "description": "This is a log.",
    "tags": [],
    "title": "Log",
    "uri": "/hugo-blog/log/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Blogs",
    "uri": "/hugo-blog/blogs/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "Canvas canvas创建 \u003ccanvas width=\"300\" height=\"200\"\u003e\u003c/canvas\u003e context 设置使用2D canvas，获取canvas的context，后续操作都是通过context\nconst ctx = canvas.getContext(\"2d\"); 绘制API 矩形 ctx.fillRect(x, y, width, height); 直线 ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); 图像 参数包括（可以分别选择前3、5、9个参数）： image、paste坐标（x1、y1）、paste大小（w1、h1）、原图坐标（x2、y2）、原图大小（w2、h2）\nconst img = new Image(); img.src = 'xxx.png'; ctx.drawImage(img, x1, y1, w1, h1, x2, y2, w2, h2); # How to Draw Images to HTML Canvas (JavaScript Tutorial)\n更多链接： HTML5 Canvas Tutorials for Beginners # Canvas HTML5 JavaScript Full Tutorial # HTML Canvas DEEP DIVE",
    "description": "Canvas canvas创建 \u003ccanvas width=\"300\" height=\"200\"\u003e\u003c/canvas\u003e context 设置使用2D canvas，获取canvas的context，后续操作都是通过context\nconst ctx = canvas.getContext(\"2d\"); 绘制API 矩形 ctx.fillRect(x, y, width, height); 直线 ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); 图像 参数包括（可以分别选择前3、5、9个参数）： image、paste坐标（x1、y1）、paste大小（w1、h1）、原图坐标（x2、y2）、原图大小（w2、h2）",
    "tags": [
      "技术笔记"
    ],
    "title": "HTML学习手册",
    "uri": "/hugo-blog/blogs/techs/html%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "包管理 npm npm init在项目中来创建package.json –yes（-y）直接默认 package.json的作用： 管理项目依赖 scripts中支持脚本运行初始化构建项目 package-lock.json：由于不同时间npm install的包版本不一致，需要用这个文件来固定版本，保证不同人安装同样的版本 npm install安装依赖，创建node_modules目录存放 –save（-S）可以自动在package.json中记录 –save-dev（-D）表示只用于develop，不用于production -g：全局（global）安装，不会出现在package.json中，可以命令行执行，例如live-server @X.X.X：安装指定版本 ^X.X.X指保持大版本，小版本和patch更新到最新 ~X.X.X指保持大版本和小版本，patch更新到最新 *指更新到最新 npm list列出项目依赖 –depth 0，不显示子依赖，1，显示一级子依赖 –global true，显示全局安装 npm update更新依赖到指定的最新版本 npm prune删除package.json中不存在的已安装依赖 npm run运行package.json中scripts指定的命令 参考链接： npm Tutorial for Beginners # NPM Full Course For Beginners - Learn NPM fundamentals and basics 扩展阅读 javascript游戏编程 Javascript Game Development Masterclass 2022",
    "description": "包管理 npm npm init在项目中来创建package.json –yes（-y）直接默认 package.json的作用： 管理项目依赖 scripts中支持脚本运行初始化构建项目 package-lock.json：由于不同时间npm install的包版本不一致，需要用这个文件来固定版本，保证不同人安装同样的版本 npm install安装依赖，创建node_modules目录存放 –save（-S）可以自动在package.json中记录 –save-dev（-D）表示只用于develop，不用于production -g：全局（global）安装，不会出现在package.json中，可以命令行执行，例如live-server @X.X.X：安装指定版本 ^X.X.X指保持大版本，小版本和patch更新到最新 ~X.X.X指保持大版本和小版本，patch更新到最新 *指更新到最新 npm list列出项目依赖 –depth 0，不显示子依赖，1，显示一级子依赖 –global true，显示全局安装 npm update更新依赖到指定的最新版本 npm prune删除package.json中不存在的已安装依赖 npm run运行package.json中scripts指定的命令 参考链接： npm Tutorial for Beginners # NPM Full Course For Beginners - Learn NPM fundamentals and basics 扩展阅读 javascript游戏编程 Javascript Game Development Masterclass 2022",
    "tags": [
      "技术笔记"
    ],
    "title": "Javascript学习手册",
    "uri": "/hugo-blog/blogs/techs/javascript%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/hugo-blog/tags/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 技术笔记",
    "uri": "/hugo-blog/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "官网链接",
    "description": "官网链接",
    "tags": [
      "技术笔记"
    ],
    "title": "像素工具Asperite",
    "uri": "/hugo-blog/blogs/asperite/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "Game Loop Game Loop的结构通常是以下三步的循环： Process Input Update Game State Draw Game 参考链接： Game Programming Patterns # Game States and Game Loops # Getting The Game Loop Right 扩展阅读",
    "description": "Game Loop Game Loop的结构通常是以下三步的循环： Process Input Update Game State Draw Game 参考链接： Game Programming Patterns # Game States and Game Loops # Getting The Game Loop Right 扩展阅读",
    "tags": [
      "技术笔记"
    ],
    "title": "游戏编程基本概念",
    "uri": "/hugo-blog/blogs/techs/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Weeklies",
    "content": "总结 Javascript进阶学习 利用原生js搭建Flappy Bird 了解javascript的包管理器 Javascript面向对象编程 OOP的四大基本原则： encapsulation（封装）：对象的内部函数可以将属性用this关键词使用 abstraction（抽象）：定义接口，隐藏内部逻辑和变量 inheritance（继承）：减少重复代码 polymorphism（多态）：不同的子类对于相同函数签名的实现 构造函数： 函数名首字母大写，内部属性用this表示，隐式返回this 调用使用new关键字，否则当作普通函数对待 对象的属性可以随时增减，因为本质就是一个{} 可以用obj[‘xxx’] = yyy来新增属性（正常是obj.xxx = yyy），这样属性名可以不用写死 delete关键字删除属性 基本类型按值拷贝，对象（{}、函数、Array）按引用拷贝 函数内用let定义私有属性，防止外部使用 getter/setter： 通过Object.defineProperty来实现 Object.defineProperty(this, 'xxx', { get: function() { return xxx; }, set: function(value) { if (value is valid) xxx = value; } }) 或者直接定义set，get class Example { constructor(value) { this._value = value; // 约定：内部存储属性 } // 公共接口：控制对属性的访问 get value() { return this._value; } set value(newValue) { this._value = newValue; } } 课程链接： # Object-oriented Programming in JavaScript: Made Super Simple | Mosh 学习Javascript ES6新特性 let和const替代var： 明确的块级作用域， 避免变量提升（hoisting），鼓励先声明后使用 防止重复声明（var可以重复声明，后者覆盖前者） 引入const，var不具有const的属性 this：指向对象本身 只有在对象调用的时候才指向对象，否则指向global object（window） 可以通过bind将函数手动绑定到对象上来正确使用this 异步函数的回调函数中的this，不会自动绑定到对象上，需要使用arrow函数或者手动绑定 const person = { name: 'Alice', talk() { // 箭头函数继承了外部 talk() 的 this (即 person) setTimeout(() =\u003e { console.log(\"this\", this); // 输出: person }, 1000); } }; person.talk(); 解构： 同名结构，如果需要重命名，可以 address = { \"a\": 1, \"b\": 2 } const {a: e, b: f} = address // 这样 e 的值才是 address.a (即 1) …： 可以展开array，例如a.concat(b)等价于[…a, …b]，展开object，例如{…a, …b} 同样的可以用来clone array class： 预留constructor关键字作为构造函数名，类似之前的首字母大写的同名函数 继承：class b extends a { … }，需要在constructor中调用super() module： 对外部需要调用的class/function加上export关键字 named：export class a { … } default：export default class a { … } 对内部需要使用的部分进行import， named：import { a } from ‘文件路径’ default：import a from ‘文件路径’ 命名（named）导出和默认（default）导出： 命名导出只能有一个，而命名导出可以多个，import a, { b, c, d } from ‘文件路径’ 在html文件中需要标记\u003cscript type=‘module’ src=‘index.js’\u003e\u003c/script\u003e 课程链接： # ES6 Tutorial: Learn Modern JavaScript in 1 Hour 开发Flappy Bird 从零开始构建Flappy Bird 了解javascript的包管理器 包管理 知识 Javascript ES6 2015年发布，主要引入let、const、class、module等 游戏图标经常通过精灵图集的方式获取，配合backgroundPosition实现 依赖requestAnimationFrame方法，基于窗口刷新不断调用游戏逻辑函数，实现Game Loop 待办 学习react框架基础知识 学习强化学习基础知识，在Flappy Bird中实现bot",
    "description": "总结 Javascript进阶学习 利用原生js搭建Flappy Bird 了解javascript的包管理器 Javascript面向对象编程 OOP的四大基本原则： encapsulation（封装）：对象的内部函数可以将属性用this关键词使用 abstraction（抽象）：定义接口，隐藏内部逻辑和变量 inheritance（继承）：减少重复代码 polymorphism（多态）：不同的子类对于相同函数签名的实现 构造函数： 函数名首字母大写，内部属性用this表示，隐式返回this 调用使用new关键字，否则当作普通函数对待 对象的属性可以随时增减，因为本质就是一个{} 可以用obj[‘xxx’] = yyy来新增属性（正常是obj.xxx = yyy），这样属性名可以不用写死 delete关键字删除属性 基本类型按值拷贝，对象（{}、函数、Array）按引用拷贝 函数内用let定义私有属性，防止外部使用 getter/setter： 通过Object.defineProperty来实现 Object.defineProperty(this, 'xxx', { get: function() { return xxx; }, set: function(value) { if (value is valid) xxx = value; } }) 或者直接定义set，get class Example { constructor(value) { this._value = value; // 约定：内部存储属性 } // 公共接口：控制对属性的访问 get value() { return this._value; } set value(newValue) { this._value = newValue; } } 课程链接： # Object-oriented Programming in JavaScript: Made Super Simple | Mosh 学习Javascript ES6新特性 let和const替代var： 明确的块级作用域， 避免变量提升（hoisting），鼓励先声明后使用 防止重复声明（var可以重复声明，后者覆盖前者） 引入const，var不具有const的属性 this：指向对象本身 只有在对象调用的时候才指向对象，否则指向global object（window） 可以通过bind将函数手动绑定到对象上来正确使用this 异步函数的回调函数中的this，不会自动绑定到对象上，需要使用arrow函数或者手动绑定 const person = { name: 'Alice', talk() { // 箭头函数继承了外部 talk() 的 this (即 person) setTimeout(() =\u003e { console.log(\"this\", this); // 输出: person }, 1000); } }; person.talk(); 解构： 同名结构，如果需要重命名，可以 address = { \"a\": 1, \"b\": 2 } const {a: e, b: f} = address // 这样 e 的值才是 address.a (即 1) …： 可以展开array，例如a.concat(b)等价于[…a, …b]，展开object，例如{…a, …b} 同样的可以用来clone array class： 预留constructor关键字作为构造函数名，类似之前的首字母大写的同名函数 继承：class b extends a { … }，需要在constructor中调用super() module： 对外部需要调用的class/function加上export关键字 named：export class a { … } default：export default class a { … } 对内部需要使用的部分进行import， named：import { a } from ‘文件路径’ default：import a from ‘文件路径’ 命名（named）导出和默认（default）导出： 命名导出只能有一个，而命名导出可以多个，import a, { b, c, d } from ‘文件路径’ 在html文件中需要标记\u003cscript type=‘module’ src=‘index.js’\u003e\u003c/script\u003e 课程链接： # ES6 Tutorial: Learn Modern JavaScript in 1 Hour 开发Flappy Bird 从零开始构建Flappy Bird 了解javascript的包管理器 包管理 知识 Javascript ES6 2015年发布，主要引入let、const、class、module等 游戏图标经常通过精灵图集的方式获取，配合backgroundPosition实现 依赖requestAnimationFrame方法，基于窗口刷新不断调用游戏逻辑函数，实现Game Loop 待办 学习react框架基础知识 学习强化学习基础知识，在Flappy Bird中实现bot",
    "tags": [
      "周记"
    ],
    "title": "Week6 Flappy Bird",
    "uri": "/hugo-blog/weekly/week6/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Weeklies",
    "uri": "/hugo-blog/weekly/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "背景 在完成css、html、javascript的基础上，构建Flappy Bird游戏，以巩固以上知识点 预备知识： Canvas [[HTML学习手册#Canvas|HTML学习手册Canvas]] Game Loop [[游戏编程基本概念#Game Loop|游戏编程基本概念Game Loop]] [[游戏编程基本概念#Game Loop|游戏编程基本概念-Game Loop]] 在线玩Flappy Bird\nGame Loop Flappy Bird的游戏逻辑设计 home：主页，显示标题和两个button（start、score），目前只实现了start ready：主页点击start进入ready页面，给出游戏提示“tap” play：在ready页面tap后进入游戏页面，包含： 初始化：小鸟、pipe和实时分数 监听用户tap： 没有tap的话有向下加速度，模拟重力 有tap行为则直接给一个向上的速度 记分：小鸟每次经过一个pipe，score加1，score超过best则覆盖best 结束：小鸟和pipe的碰撞检测，碰到上下边缘或者pipe则结束，进入结束页面 over： 结束页面显示记分牌，显示奖牌（是best则金牌，不然白牌），显示score和best 给出ok和menu按钮，其中ok回到ready页，menu回到home页 技术细节 精灵图集 Sprite 精灵图集将游戏中所有的小图片（如小鸟、管道、背景、按钮等）集中在一个大文件里 在网页中获取的时候，可以使用CSS Sprites技术：使用 background-image 和 background-position 两个属性来在网页元素中显示精灵图集上的某一个图标或图片 可以使用 Sprite Cow对精灵图集进行分割处理，得到每个图标的position 注意图标推荐放在div或者span中，而不是img中 如何实现游戏基本逻辑 利用requestAnimationFrame（简单来说，rAF告诉浏览器：“我要执行一个动画，请在下一次重绘（Repaint）之前调用我的回调函数。”），将Game Loop函数作为callback，从而不断刷新游戏状态，实现元素的移动，以及整体Game Loop function GameLoop() { //移动小鸟 ... // 更新游戏分数 updateGameScore(); // 更新pipes的状态 updatePipes(); // 边界碰撞检测 if (birdPosY \u003c 0 || birdPosY + 22 \u003e 400) { console.log(\"Hit Boundary\"); game_state = \"ended\"; } // pipe碰撞检测 ... if (game_state === \"ended\") { ... console.log(\"Game Over!\"); return; } requestAnimationFrame(GameLoop); } 如何实现背景的移动 css中将背景设置为精灵图集中的一部分，且repeat-x，水平循环 #scene { position: relative; /* 改为相对定位，由 flex 控制居中 */ border: 5px solid red; box-sizing: border-box; /* 让 border 包含在宽高内 */ display: flex; align-items: center; justify-content: center; flex-direction: column; background: url('../images/flappy-bird-sprite.png') repeat-x 0 0; image-rendering: pixelated; width: 225px; /* 原始宽度 */ height: 400px; /* 原始高度 */ overflow: hidden; /* 确保内容不溢出游戏画面 */ } 在js中设置scene的backgroundPostion可以整体移动 scene.style.backgroundPosition = `-${backgroundX}px 0px`; 如何实现小鸟的移动 水平方向上不移动，固定在屏幕30%位置上 #bird { position: absolute; background: url('../images/flappy-bird-sprite.png') no-repeat -179px -513px; width: 28px; height: 22px; top: 200px; left: 30%; transform: translateX(-50%); } 垂直方向上，根据游戏逻辑，确定位置后，通过top来实现移动 // 重力加速度下降 birdSpeedY += 0.1; birdPosY = birdPosY + birdSpeedY; bird.style.top = `${birdPosY}px`; 如何实现小鸟扇动翅膀 对于小鸟这个div，根据时间不断切换精灵图集中的backgroundPosition，从而切换不同图片 // 小鸟扇翅膀动画 birdFrameTimer++; if (birdFrameTimer % birdWingRate === 0) { // 每10帧切换一次图片，数字越小越快 birdFrameIndex = (birdFrameIndex + 1) % birdFrames.length; bird.style.backgroundPosition = birdFrames[birdFrameIndex]; if (birdFrameTimer === birdWingRate) { birdFrameTimer = 0; } } 如何实现管道的平移 在html中写三组pipe元素 在js中通过transform水平移动，如果移动超过屏幕，则从最左侧重置到最右侧 // 如果移出屏幕左侧，移动到最右侧 if (pipe.x \u003c -pipeWidth) { // 找到当前最右边的管道的 x 坐标 let maxX = Math.max(...pipesData.map(p =\u003e p.x)); pipe.x = maxX + pipeDistance; // 重新随机高度 pipe.y = Math.floor(Math.random() * (300 - 100)) + 100; pipe.scored = false; } 如何实现页面切换 在html中写在一起 \u003cdiv id=\"scene\"\u003e \u003c!-- 首页场景 --\u003e \u003cdiv id=\"scene_home\"\u003e ... \u003c/div\u003e \u003c!-- 游戏准备场景 (默认隐藏) --\u003e \u003cdiv id=\"scene_ready\" style=\"display: none;\"\u003e ... \u003c/div\u003e \u003c!-- 游戏场景 (默认隐藏) --\u003e \u003cdiv id=\"scene_play\" style=\"display: none;\"\u003e ... \u003c/div\u003e \u003c!-- 游戏结束场景（默认隐藏）--\u003e \u003cdiv id=\"scene_over\" style=\"display: none;\"\u003e ... \u003c/div\u003e \u003c/div\u003e 然后通过在js中设定某一个部分（div）的display是否为none，来切换显示不同部分 document.getElementById(\"ok_button\").addEventListener('click', function(){ // 隐藏首页场景 document.getElementById(\"scene_over\").style.display = 'none'; // 隐藏游戏层 document.getElementById(\"scene_play\").style.display = 'none'; // 显示游戏场景 document.getElementById(\"scene_ready\").style.display = 'flex'; // 游戏状态进入ready game_state = \"ready\"; }); 代码仓库 github链接： flappy-bird",
    "description": "背景 在完成css、html、javascript的基础上，构建Flappy Bird游戏，以巩固以上知识点 预备知识： Canvas [[HTML学习手册#Canvas|HTML学习手册Canvas]] Game Loop [[游戏编程基本概念#Game Loop|游戏编程基本概念Game Loop]] [[游戏编程基本概念#Game Loop|游戏编程基本概念-Game Loop]] 在线玩Flappy Bird\nGame Loop Flappy Bird的游戏逻辑设计 home：主页，显示标题和两个button（start、score），目前只实现了start ready：主页点击start进入ready页面，给出游戏提示“tap” play：在ready页面tap后进入游戏页面，包含： 初始化：小鸟、pipe和实时分数 监听用户tap： 没有tap的话有向下加速度，模拟重力 有tap行为则直接给一个向上的速度 记分：小鸟每次经过一个pipe，score加1，score超过best则覆盖best 结束：小鸟和pipe的碰撞检测，碰到上下边缘或者pipe则结束，进入结束页面 over： 结束页面显示记分牌，显示奖牌（是best则金牌，不然白牌），显示score和best 给出ok和menu按钮，其中ok回到ready页，menu回到home页 技术细节 精灵图集 Sprite 精灵图集将游戏中所有的小图片（如小鸟、管道、背景、按钮等）集中在一个大文件里 在网页中获取的时候，可以使用CSS Sprites技术：使用 background-image 和 background-position 两个属性来在网页元素中显示精灵图集上的某一个图标或图片 可以使用 Sprite Cow对精灵图集进行分割处理，得到每个图标的position 注意图标推荐放在div或者span中，而不是img中 如何实现游戏基本逻辑 利用requestAnimationFrame（简单来说，rAF告诉浏览器：“我要执行一个动画，请在下一次重绘（Repaint）之前调用我的回调函数。”），将Game Loop函数作为callback，从而不断刷新游戏状态，实现元素的移动，以及整体Game Loop function GameLoop() { //移动小鸟 ... // 更新游戏分数 updateGameScore(); // 更新pipes的状态 updatePipes(); // 边界碰撞检测 if (birdPosY \u003c 0 || birdPosY + 22 \u003e 400) { console.log(\"Hit Boundary\"); game_state = \"ended\"; } // pipe碰撞检测 ... if (game_state === \"ended\") { ... console.log(\"Game Over!\"); return; } requestAnimationFrame(GameLoop); } 如何实现背景的移动 css中将背景设置为精灵图集中的一部分，且repeat-x，水平循环 #scene { position: relative; /* 改为相对定位，由 flex 控制居中 */ border: 5px solid red; box-sizing: border-box; /* 让 border 包含在宽高内 */ display: flex; align-items: center; justify-content: center; flex-direction: column; background: url('../images/flappy-bird-sprite.png') repeat-x 0 0; image-rendering: pixelated; width: 225px; /* 原始宽度 */ height: 400px; /* 原始高度 */ overflow: hidden; /* 确保内容不溢出游戏画面 */ } 在js中设置scene的backgroundPostion可以整体移动 scene.style.backgroundPosition = `-${backgroundX}px 0px`; 如何实现小鸟的移动 水平方向上不移动，固定在屏幕30%位置上 #bird { position: absolute; background: url('../images/flappy-bird-sprite.png') no-repeat -179px -513px; width: 28px; height: 22px; top: 200px; left: 30%; transform: translateX(-50%); } 垂直方向上，根据游戏逻辑，确定位置后，通过top来实现移动 // 重力加速度下降 birdSpeedY += 0.1; birdPosY = birdPosY + birdSpeedY; bird.style.top = `${birdPosY}px`; 如何实现小鸟扇动翅膀 对于小鸟这个div，根据时间不断切换精灵图集中的backgroundPosition，从而切换不同图片 // 小鸟扇翅膀动画 birdFrameTimer++; if (birdFrameTimer % birdWingRate === 0) { // 每10帧切换一次图片，数字越小越快 birdFrameIndex = (birdFrameIndex + 1) % birdFrames.length; bird.style.backgroundPosition = birdFrames[birdFrameIndex]; if (birdFrameTimer === birdWingRate) { birdFrameTimer = 0; } } 如何实现管道的平移 在html中写三组pipe元素 在js中通过transform水平移动，如果移动超过屏幕，则从最左侧重置到最右侧 // 如果移出屏幕左侧，移动到最右侧 if (pipe.x \u003c -pipeWidth) { // 找到当前最右边的管道的 x 坐标 let maxX = Math.max(...pipesData.map(p =\u003e p.x)); pipe.x = maxX + pipeDistance; // 重新随机高度 pipe.y = Math.floor(Math.random() * (300 - 100)) + 100; pipe.scored = false; } 如何实现页面切换 在html中写在一起 \u003cdiv id=\"scene\"\u003e \u003c!-- 首页场景 --\u003e \u003cdiv id=\"scene_home\"\u003e ... \u003c/div\u003e \u003c!-- 游戏准备场景 (默认隐藏) --\u003e \u003cdiv id=\"scene_ready\" style=\"display: none;\"\u003e ... \u003c/div\u003e \u003c!-- 游戏场景 (默认隐藏) --\u003e \u003cdiv id=\"scene_play\" style=\"display: none;\"\u003e ... \u003c/div\u003e \u003c!-- 游戏结束场景（默认隐藏）--\u003e \u003cdiv id=\"scene_over\" style=\"display: none;\"\u003e ... \u003c/div\u003e \u003c/div\u003e 然后通过在js中设定某一个部分（div）的display是否为none，来切换显示不同部分 document.getElementById(\"ok_button\").addEventListener('click', function(){ // 隐藏首页场景 document.getElementById(\"scene_over\").style.display = 'none'; // 隐藏游戏层 document.getElementById(\"scene_play\").style.display = 'none'; // 显示游戏场景 document.getElementById(\"scene_ready\").style.display = 'flex'; // 游戏状态进入ready game_state = \"ready\"; }); 代码仓库 github链接： flappy-bird",
    "tags": [
      "技术笔记"
    ],
    "title": "从零开始构建Flappy Bird",
    "uri": "/hugo-blog/blogs/techs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAflappy-bird/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag :: 周记",
    "uri": "/hugo-blog/tags/%E5%91%A8%E8%AE%B0/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Weeklies",
    "content": "总结 完成neovim环境搭建 熟练vim操作 完成javascript基础知识学习 neovim配置 学习lua的基础知识： Lua 配置Neovim环境，安装所需插件： Vim和NeoVim 学习javascript基础知识 javascript课程学习 ===：三个等号是全等，即对象类型和值均相等，两个等号只代表值相等 …：可变参数，比如function foo (a, b, …c)，c获取剩余可变参数 typeof：类型判断，如typeof xxx !== ‘function’ for循环： 对array（可迭代对象，包括map）可以用of for(ele of elements) {...} 对object属性可以用in for(property in element) {...} forEach函数接受的callback可以最多包含element、index、array三个参数 map函数相比forEach的区别：返回新的array；类似的还有filter reduce函数接受accumulator和element两个参数，最终返回一个element arrow function：一种函数定义的简化：() =\u003e … ()里面填参数，…填函数实现，多用于简单的one-liner fruits.forEach(fruit =\u003e console.log(fruit.calories)); this：使用当前对象作为this arrow function中的this的指向是代码位置确定的（词法定义域，Lexical Scope），而不是他被调用时确定的，因此在回调函数函数中可以绑定到当前对象（如果是普通函数作为回调函数，this在运行时才确定，已经和对象失联，只会绑定到global object） 可以用来实现constructor（ES6新特性支持class） super：使用父类方法 在子类中定义constructor时要首先使用父类的constructor，即super(xxx) setter和getter：用set和get关键字函数，定义class的私有属性的读写 外部只通过setter和getter读写私有属性，逻辑可控（比如类型检查） destructuring： 通过[]来解构array内容，例如swap a，b：[a,b] = [b,a] const elements = ['a', 'b', 'c', 'd', 'e']; // a = 'a', b = 'b', c = 'c', r = ['d', 'e'] const [a, b, c, ...r] = elements; 通过{}来解构object内容，可以在function的参数使用这个方式 function displayPerson({firstname, lastname}) { console.log(firstname); console.log(lastname); } sort：默认情况按lexicographic（字母+数字+符号）排序，即1、10、2、3… 可以添加cmp：numbers.sort((a,b) =\u003e a - b)，来进行数字排序 string属性不能用减法，转成NAN后都相等，需要a.name.localeCompare(b.name) shuffle：没有内置的shuffle，需要自己实现Fisher-Yates算法 setTimeout：等待一段时间（毫秒）后执行函数，可以通过clearTimeout取消 module：代码通过模块载入，类似python的import 在html的script标签里加上type=“module”，将index.js当作module载入 变量和函数前需要加上export关键字 在index.js头部加上import {变量名、函数名} from ‘文件路径’ async： setTimeout就是一个异步函数的例子，不阻碍主线程 一般通过callback、promise、async/await实现 当使用callback来串联异步函数时，会出现callback hell现象，即callback嵌套过度让代码可读性变差，可以通过promise或者async/await解决 promise：用来管理异步操作的对象 异步函数foo()返回promise对象，new Promise((resolve, reject)) =\u003e {异步逻辑} 用.then来承接异步函数，即foo().then(value =\u003e {…})，then里面写resolve处理逻辑 resolve函数可以返回另一个promise，用来串联下一个异步函数 用.catch来承接异步函数，即foo().catch(error =\u003e {…})，catch里面写reject处理逻辑 reject函数指定失败的逻辑，对整体异步链生效，无法针对其中的某个异步函数单独指定reject 如果想对某个异步函数实现单独失败处理，有如下两种方案： 方法一：.then中加入(error =\u003e {…})的部分 方法二：在异步函数中的reject参数中给出类型，在后续统一的catch中按类型实现单独逻辑 async/await：用同步的方式写异步 async让一个函数返回promise 是个语法糖，自动将函数返回结果包装在Promise.resolve()中 await让一个异步函数等待一个promise 通过写一个async关键词的函数来包含多个异步函数，每个异步函数用await来等待结果，用try/catch来捕获异步过程中的error，可以将上述promise的链式调用改写为同步风格的函数： function bar() { return new Promise((...)) } function fuz() { return new Promise((...)) } async function foo() { xxx = await bar(); yyy = await fuz(); } 异常捕获： 使用try、catch、finally拦截异常 使用throw new Error()抛出异常 DOM：Document Object Model 浏览器加载html构建DOM，将元素以树形结构展示 javascript可以通过DOM动态改变网页的内容、结构和样式 动态（live）获取，指查询后的改变能实时更新，类似于引用： getElementById：精准获取element getElementsClassName返回html collection，注意不等同于array，比如不支持forEach操作，可以用Array.from(XXX)来转化为array getElementsByTagName返回所有tag（如h2）下面的html collection 静态（static）获取，指查一次，子元素不再改变，类似于快照、拷贝： querySelector/querySelectorAll通过类似css的获取方式（./#） querySelector获取第一个element querySelectorAll获取nodelist，一般用forEach遍历 可以用console.dir(document)来显示结构 修改html： 添加三部曲：构建element、添加属性、插入DOM（基于父节点） 删除：removeChild，基于父节点 事件监听：eventListener 监听click、mouseover、mouseout、keydown、keyup事件 .addEventListener(event, callback) 可以通过DOMContentLoaded事件来等待dom加载完成后再加载图片 classList：通过api访问className，来修改元素的css类，相当于通过js给页面动态加样式 支持add、remove、toggle、replace、contains操作 JSON：stringify和parse实现js obect和json string的相互转换 fetch：异步函数，通过路径（本地或远程连接）读取数据 课程链接 # JavaScript Full Course for free # JavaScript Tutorial Full Course - Beginner to Pro 知识 NeoVim是Vim的新版本重构 通过LazyNvim插件配置 支持语法高亮、语义补全、代码跳转、git等几乎全部所需功能 基本替代vscode，熟练掌握vim操作后，效率提升 html负责内容、css负责样式、javascript负责交互 通过nodejs的live-server可以同步更新目录内的网页状态，类似vscode里的go live插件 node开启javascript命令行 待办 了解javscript进阶知识：ES6+新特性 Flappy Bird开发",
    "description": "总结 完成neovim环境搭建 熟练vim操作 完成javascript基础知识学习 neovim配置 学习lua的基础知识： Lua 配置Neovim环境，安装所需插件： Vim和NeoVim 学习javascript基础知识 javascript课程学习 ===：三个等号是全等，即对象类型和值均相等，两个等号只代表值相等 …：可变参数，比如function foo (a, b, …c)，c获取剩余可变参数 typeof：类型判断，如typeof xxx !== ‘function’ for循环： 对array（可迭代对象，包括map）可以用of for(ele of elements) {...} 对object属性可以用in for(property in element) {...} forEach函数接受的callback可以最多包含element、index、array三个参数 map函数相比forEach的区别：返回新的array；类似的还有filter reduce函数接受accumulator和element两个参数，最终返回一个element arrow function：一种函数定义的简化：() =\u003e … ()里面填参数，…填函数实现，多用于简单的one-liner fruits.forEach(fruit =\u003e console.log(fruit.calories)); this：使用当前对象作为this arrow function中的this的指向是代码位置确定的（词法定义域，Lexical Scope），而不是他被调用时确定的，因此在回调函数函数中可以绑定到当前对象（如果是普通函数作为回调函数，this在运行时才确定，已经和对象失联，只会绑定到global object） 可以用来实现constructor（ES6新特性支持class） super：使用父类方法 在子类中定义constructor时要首先使用父类的constructor，即super(xxx) setter和getter：用set和get关键字函数，定义class的私有属性的读写 外部只通过setter和getter读写私有属性，逻辑可控（比如类型检查） destructuring： 通过[]来解构array内容，例如swap a，b：[a,b] = [b,a] const elements = ['a', 'b', 'c', 'd', 'e']; // a = 'a', b = 'b', c = 'c', r = ['d', 'e'] const [a, b, c, ...r] = elements; 通过{}来解构object内容，可以在function的参数使用这个方式 function displayPerson({firstname, lastname}) { console.log(firstname); console.log(lastname); } sort：默认情况按lexicographic（字母+数字+符号）排序，即1、10、2、3… 可以添加cmp：numbers.sort((a,b) =\u003e a - b)，来进行数字排序 string属性不能用减法，转成NAN后都相等，需要a.name.localeCompare(b.name) shuffle：没有内置的shuffle，需要自己实现Fisher-Yates算法 setTimeout：等待一段时间（毫秒）后执行函数，可以通过clearTimeout取消 module：代码通过模块载入，类似python的import 在html的script标签里加上type=“module”，将index.js当作module载入 变量和函数前需要加上export关键字 在index.js头部加上import {变量名、函数名} from ‘文件路径’ async： setTimeout就是一个异步函数的例子，不阻碍主线程 一般通过callback、promise、async/await实现 当使用callback来串联异步函数时，会出现callback hell现象，即callback嵌套过度让代码可读性变差，可以通过promise或者async/await解决 promise：用来管理异步操作的对象 异步函数foo()返回promise对象，new Promise((resolve, reject)) =\u003e {异步逻辑} 用.then来承接异步函数，即foo().then(value =\u003e {…})，then里面写resolve处理逻辑 resolve函数可以返回另一个promise，用来串联下一个异步函数 用.catch来承接异步函数，即foo().catch(error =\u003e {…})，catch里面写reject处理逻辑 reject函数指定失败的逻辑，对整体异步链生效，无法针对其中的某个异步函数单独指定reject 如果想对某个异步函数实现单独失败处理，有如下两种方案： 方法一：.then中加入(error =\u003e {…})的部分 方法二：在异步函数中的reject参数中给出类型，在后续统一的catch中按类型实现单独逻辑 async/await：用同步的方式写异步 async让一个函数返回promise 是个语法糖，自动将函数返回结果包装在Promise.resolve()中 await让一个异步函数等待一个promise 通过写一个async关键词的函数来包含多个异步函数，每个异步函数用await来等待结果，用try/catch来捕获异步过程中的error，可以将上述promise的链式调用改写为同步风格的函数： function bar() { return new Promise((...)) } function fuz() { return new Promise((...)) } async function foo() { xxx = await bar(); yyy = await fuz(); } 异常捕获： 使用try、catch、finally拦截异常 使用throw new Error()抛出异常 DOM：Document Object Model 浏览器加载html构建DOM，将元素以树形结构展示 javascript可以通过DOM动态改变网页的内容、结构和样式 动态（live）获取，指查询后的改变能实时更新，类似于引用： getElementById：精准获取element getElementsClassName返回html collection，注意不等同于array，比如不支持forEach操作，可以用Array.from(XXX)来转化为array getElementsByTagName返回所有tag（如h2）下面的html collection 静态（static）获取，指查一次，子元素不再改变，类似于快照、拷贝： querySelector/querySelectorAll通过类似css的获取方式（./#） querySelector获取第一个element querySelectorAll获取nodelist，一般用forEach遍历 可以用console.dir(document)来显示结构 修改html： 添加三部曲：构建element、添加属性、插入DOM（基于父节点） 删除：removeChild，基于父节点 事件监听：eventListener 监听click、mouseover、mouseout、keydown、keyup事件 .addEventListener(event, callback) 可以通过DOMContentLoaded事件来等待dom加载完成后再加载图片 classList：通过api访问className，来修改元素的css类，相当于通过js给页面动态加样式 支持add、remove、toggle、replace、contains操作 JSON：stringify和parse实现js obect和json string的相互转换 fetch：异步函数，通过路径（本地或远程连接）读取数据 课程链接 # JavaScript Full Course for free # JavaScript Tutorial Full Course - Beginner to Pro 知识 NeoVim是Vim的新版本重构 通过LazyNvim插件配置 支持语法高亮、语义补全、代码跳转、git等几乎全部所需功能 基本替代vscode，熟练掌握vim操作后，效率提升 html负责内容、css负责样式、javascript负责交互 通过nodejs的live-server可以同步更新目录内的网页状态，类似vscode里的go live插件 node开启javascript命令行 待办 了解javscript进阶知识：ES6+新特性 Flappy Bird开发",
    "tags": [
      "周记"
    ],
    "title": "Week5 javascript学习",
    "uri": "/hugo-blog/weekly/week5/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "",
    "description": "",
    "tags": [
      "技术笔记"
    ],
    "title": "Agent",
    "uri": "/hugo-blog/blogs/techs/agent/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Weeklies",
    "content": "总结 优化本地开发环境 tmux配置 Tmux使用教程 aerospace配置 Aerospace使用教程 iterm2配置 Terminal配置 知识 通过tmux解决同一个shell下多开进程的操作方式 tmux分为session、window、pane，每个session下可以快速切换window和pane 通过aerospace可以通过键盘快速切换操作页面，如chrome、terminal、obsidian之间 linux上使用i3，macOS上使用aerospace terminal配置主要包含以下几步 安装terminal 安装color themes 安装字体：支持定制化图标 安装插件：powerlevel10k（未使用）、zsh的语义补全和语法高亮 待办 配置neovim环境 熟练vim操作",
    "description": "总结 优化本地开发环境 tmux配置 Tmux使用教程 aerospace配置 Aerospace使用教程 iterm2配置 Terminal配置 知识 通过tmux解决同一个shell下多开进程的操作方式 tmux分为session、window、pane，每个session下可以快速切换window和pane 通过aerospace可以通过键盘快速切换操作页面，如chrome、terminal、obsidian之间 linux上使用i3，macOS上使用aerospace terminal配置主要包含以下几步 安装terminal 安装color themes 安装字体：支持定制化图标 安装插件：powerlevel10k（未使用）、zsh的语义补全和语法高亮 待办 配置neovim环境 熟练vim操作",
    "tags": [
      "周记"
    ],
    "title": "Week4 开发环境优化",
    "uri": "/hugo-blog/weekly/week4/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "背景 Aerospace是linux系统上i3窗口管理器应用的macOS系统上的替代应用\n支持设置多个workspace，在workspace内管理（平铺或者移动）窗口 支持给每个workspace设定快捷键，进行快速切入 使用说明 配置文件：~/.config/aerospace/aerospace.toml\nmain mode： 设置workspace快捷键：alt+数字/字母 切换窗口：alt+hjkl 移动窗口：alt+shift+hjkl 放大/缩小窗口：alt+shift+（=-） 切换横竖分割：alt+/ 切换横竖全屏：alt+, service mode： reload config：alt+shift+; 相关链接： # Aerospace Is The Best Tiling Window Manager I’ve Tried On macOS",
    "description": "背景 Aerospace是linux系统上i3窗口管理器应用的macOS系统上的替代应用\n支持设置多个workspace，在workspace内管理（平铺或者移动）窗口 支持给每个workspace设定快捷键，进行快速切入 使用说明 配置文件：~/.config/aerospace/aerospace.toml\nmain mode： 设置workspace快捷键：alt+数字/字母 切换窗口：alt+hjkl 移动窗口：alt+shift+hjkl 放大/缩小窗口：alt+shift+（=-） 切换横竖分割：alt+/ 切换横竖全屏：alt+, service mode： reload config：alt+shift+; 相关链接： # Aerospace Is The Best Tiling Window Manager I’ve Tried On macOS",
    "tags": [],
    "title": "Aerospace使用教程",
    "uri": "/hugo-blog/blogs/aerospace%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "参考链接： Learn X in Y minutes # Lua, the simplest language to learn",
    "description": "参考链接： Learn X in Y minutes # Lua, the simplest language to learn",
    "tags": [],
    "title": "Lua",
    "uri": "/hugo-blog/blogs/lua/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "iTerm2 color themes 下载iterm2的色彩主题，可以选择以下颜色组合，搭配neovim使用 # Iterm2-color-schemes Oh My Zsh 安装oh my zsh，一键配置zsh的.zshrc github链接\nfonts 下载字体以支持一些开发相关的图标 nerd fonts\n插件 语法高亮： zsh-syntax-highlighting 语义补全： zsh-autosuggestions fzf：\nctrl + f：进行目录下的文件查找（目前扩展为在home目录下的dir） ctrl + t：进行目录下的目录查找（同上） ctrl + r：显示history **：会根据当前命令前缀查找候选 cd **：列出目录，仅限当前目录下，和上面的生效区域不同 export **：列出环境变量 ssh **：列出最近访问过的hostname kill -9 **：列出进程 参考链接：\n# How to setup your Mac Terminal to be beautiful",
    "description": "iTerm2 color themes 下载iterm2的色彩主题，可以选择以下颜色组合，搭配neovim使用 # Iterm2-color-schemes Oh My Zsh 安装oh my zsh，一键配置zsh的.zshrc github链接\nfonts 下载字体以支持一些开发相关的图标 nerd fonts",
    "tags": [],
    "title": "Terminal配置",
    "uri": "/hugo-blog/blogs/terminal%E9%85%8D%E7%BD%AE/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "参考链接：\nContext Rot: How Increasing Input Tokens Impacts LLM Performance",
    "description": "参考链接：\nContext Rot: How Increasing Input Tokens Impacts LLM Performance",
    "tags": [],
    "title": "Context Rot",
    "uri": "/hugo-blog/blogs/techs/context-rot/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "pip 一般通过freeze的命令记录目前全部环境依赖\npip freeze \u003e requirements.txt 其他人可以通过pip的方式一键安装全部环境以来\npip install -r requirements.txt 缺陷 pip install会将库安装到全局目录，多用户共享，导致版本依赖和兼容性问题 pip freeze的问题在于无法明确区分哪些是项目的直接依赖，只是一股脑的记录 pip uninstall后，对应的间接依赖不会被卸载掉 venv 在项目目录里执行，创建.venv虚拟python环境，名称推荐叫.venv，因为vscode等可以自动识别\npython3 -m venv .venv 通过active激活环境，并通过deactivate关闭环境\n// 激活环境 source .venv/bin/activate // 关闭环境 deactivate pyproject.toml 目标就是统一不同的配置文件，把所有与项目构建（打包、依赖管理）和工具配置相关的设置都放在这一个文件里\n完整示例：\n# 指定构建项目的工具 [build-system] requires = [\"setuptools\u003e=45\", \"wheel\"] build-backend = \"setuptools.build_meta\" [project] name = \"my-cli-tool\" version = \"0.1.0\" description = \"一个强大的命令行工具\" authors = [{name = \"王五\", email = \"wangwu@example.com\"}] readme = \"README.md\" license = {text = \"MIT\"} requires-python = \"\u003e=3.8\" # 运行时依赖 dependencies = [ \"requests\u003e=2.25.1\", \"rich\u003e=10.0.0\", ] classifiers = [ \"License :: OSI Approved :: MIT License\", \"Programming Language :: Python :: 3\", ] # 可选依赖 [project.optional-dependencies] dev = [\"pytest\", \"black\", \"flake8\"] # 命令行运行模块函数 [project.scripts] my-tool = \"my_tool.main:cli\" # 工具配置参数 [tool.black] line-length = 88 [tool.pytest.ini_options] addopts = \"-v\" testpaths = [\"tests\"] 通过以下命令可以一键安装\npip install -e . 缺陷 通过venv和pyproject.toml的方式管理和安装库，导致每次安装新库，需要查找对应的版本号，并手动添加到toml配置文件中 UV 为用户封装了管理项目的库安装和配置过程 安装uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh 通过uv add命令替代pip install\nuv add flask 可以对目录下的pyproject.toml进行自动更新 检查并自动创建.venv虚拟环境 将库和所有依赖均安装到.venv环境中 通过sync命令搭建虚拟环境并安装项目全部依赖\nuv sync 通过run命令可以自动找到venv环境，并省略手动activate环境这步，直接运行代码\n# 直接运行 uv run main.py # 使用特定目录作为虚拟环境 uv --python 3.11 run script.py # 使用系统Python uv --system run script.py # 指定虚拟环境路径 uv --with-venv /path/to/venv run script.py 通过tool install命令可以安装虚拟环境外的工具库，整个系统可用\nuv tool install ruff 通过build命令可以进行项目打包成whl文件\nuv build 参考链接：\n# 从pip到uv：一口气梳理现代Python项目管理全流程！ # 用uv管理Python的一切！",
    "description": "pip 一般通过freeze的命令记录目前全部环境依赖\npip freeze \u003e requirements.txt 其他人可以通过pip的方式一键安装全部环境以来\npip install -r requirements.txt 缺陷 pip install会将库安装到全局目录，多用户共享，导致版本依赖和兼容性问题 pip freeze的问题在于无法明确区分哪些是项目的直接依赖，只是一股脑的记录 pip uninstall后，对应的间接依赖不会被卸载掉 venv 在项目目录里执行，创建.venv虚拟python环境，名称推荐叫.venv，因为vscode等可以自动识别\npython3 -m venv .venv 通过active激活环境，并通过deactivate关闭环境\n// 激活环境 source .venv/bin/activate // 关闭环境 deactivate pyproject.toml 目标就是统一不同的配置文件，把所有与项目构建（打包、依赖管理）和工具配置相关的设置都放在这一个文件里",
    "tags": [],
    "title": "Python项目管理",
    "uri": "/hugo-blog/blogs/python%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "Vim Vim分为两个概念，编辑器和motion\n编辑器指ui，功能提供的模块，在neovim中进行插件化配置优化 motion指vim的基础操作命令，这部分在neovim中通用 操作命令 删除：d 修改：c 替换：r 撤销：u 重做：ctrl+r 移动： 按字符移动：上：k；下：j；左：h；右：l 行数+上下：例如向上8行是8k 按词移动，向前到词首：b；向后到下一个词首：w，向后到词尾：e 到行首：0，到行首非空字符：_ ，到行尾：$ 到指定字符： 到下一个指定字符：f，例如ft到下一个t；F到上一个 到下一个指定字符前：t，例如ta到下一个a前；T到上一个 重复到下一个：; 重复到上一个：, 按paragraph移动：上：{；下：}; 按页移动：ctrl+u：向上半页；ctrl+d：向下半页 进入insert mode： 到下一个字符：a 到最后一个字符后面：A 到第一个字符前面：I 新建下一行：o 新建上一行：O 手动缩进：向左：\u003c；向右：\u003e； 可以同时缩进多行，在首行\u003e4j：包括首行一共缩进5行 搜索： /：搜索下一个；？：默认搜索上一个 *：搜索下一个当前光标对应单词；#：搜索上一个当前光标对应单词 光标居中（中间行）：zz text object：动作（v/y/d）+选中类型（i/a）+object类型（w/W/s/p） 例如：viw（选中当前单词）；viW（选中当前连续字符） 将下一行拼接到当前行，用空格分割： J 重复上一次操作：. 重要概念 Text Object 参考链接：\n# Vim As Your Editor # Vim中的重要概念 Text Object\nNeoVim neovim内置lua引擎，可以用lua编写插件和配置，易读且功能强大 配置文件位置：~/.config/nvim/init.lua 重要概念 LSP 代码编辑过程中，需要和ls（language server）进行交互，来获取当前代码的状态（定义、引用、诊断等），两者之间的交互基于LSP（language server protocol）\nlspconfig 每次编辑器启动ls的时候，需要给出配置（包括什么时候启动、当前语言等），这时候就需要lspconfig插件： nvim-lspconfig\n对每一种语言安装对应的插件，来支持对应语言的lsp # LSP in Neovim (with like 3 lines of code) nvim在0.11之后可以更方便的安装配置lsp # How to Setup Neovim LSP Like A Pro in 2025 (v0.11+) 插件 可以使用lazy.nvim来帮助安装插件，其中重要的包括：\nneo-tree 提供左侧文件目录，可以浏览目录结构，进行文件的增删改 通过ctrl-w + 方向键可以切换目录和文件窗口 在目录中文件上按t可以在新的tab中打开 bufferline 管理buffer的工具，可以方便在buffer之间切换： 上一个buffer：[b 下一个buffer：]b telescope 方便在目录内查找文件，字符串等 leader + ff（find files） 进行文件查找 leader + fg（live grep） 进行关键词查找 treesitter 基于语言将文本进行结构化理解 实现语法高亮，支持text object、incremental selection等能力 text object支持diw（internal delete word）、vap（visual around paragraph）等操作 incremental selection：ctrl+space nvim-cmp 基于treesitter的理解，实现代码补全 另外autopair实现引号等配对补全，autotag实现html标签配对补全 mason mason是一个管理lsp下载、安装的工具 通过ui完成lsp、包括linter、formatter的安装 mason-lspconfig可以帮助nvim找到nvim-lspconfig的配置，传给lsp 最终lsp实现代码的定义、引用等跳转，并可以进行代码错误识别，给出诊断和code action 定义跳转：gd 引用跳转：gR 显示诊断：leader+d（当前行），leader+D（当前文件） lazygit 在nvim中进行git操作，支持add、commit、push等 减少从nvim出来进入命令行git的操作 参考链接： # Lazygit - The Best Way To Use Git On The Terminal \u0026 Neovim 参考链接：\n# The Only Video You Need to Get Started with Neovim\n# NeoVim 从平凡到非凡\n# How I Setup Neovim To Make It AMAZING in 2024: The Ultimate Guide",
    "description": "Vim Vim分为两个概念，编辑器和motion\n编辑器指ui，功能提供的模块，在neovim中进行插件化配置优化 motion指vim的基础操作命令，这部分在neovim中通用 操作命令 删除：d 修改：c 替换：r 撤销：u 重做：ctrl+r 移动： 按字符移动：上：k；下：j；左：h；右：l 行数+上下：例如向上8行是8k 按词移动，向前到词首：b；向后到下一个词首：w，向后到词尾：e 到行首：0，到行首非空字符：_ ，到行尾：$ 到指定字符： 到下一个指定字符：f，例如ft到下一个t；F到上一个 到下一个指定字符前：t，例如ta到下一个a前；T到上一个 重复到下一个：; 重复到上一个：, 按paragraph移动：上：{；下：}; 按页移动：ctrl+u：向上半页；ctrl+d：向下半页 进入insert mode： 到下一个字符：a 到最后一个字符后面：A 到第一个字符前面：I 新建下一行：o 新建上一行：O 手动缩进：向左：\u003c；向右：\u003e； 可以同时缩进多行，在首行\u003e4j：包括首行一共缩进5行 搜索： /：搜索下一个；？：默认搜索上一个 *：搜索下一个当前光标对应单词；#：搜索上一个当前光标对应单词 光标居中（中间行）：zz text object：动作（v/y/d）+选中类型（i/a）+object类型（w/W/s/p） 例如：viw（选中当前单词）；viW（选中当前连续字符） 将下一行拼接到当前行，用空格分割： J 重复上一次操作：. 重要概念 Text Object",
    "tags": [],
    "title": "Vim和NeoVim",
    "uri": "/hugo-blog/blogs/vim%E5%92%8Cneovim/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "背景 全称terminal multiplexer 一个session可以包含多个子进程window，可以切换显示多个子进程 一个window又可以分割成多个分屏pane，方便编辑和后台运行任务 一个session保存了多个子进程信息，关闭terminal后可以重新恢复session 可以使用tmux运行长时间任务，后台运行防止关闭terminal导致杀死进程 可以在不同session、window和pane之间切换 使用说明 命令行操作 tmux：自动创建session tmux new -s 名字：创建命名session tmux ls：列出tmux全部session tmux a -t 数字：进入指定session，如果只有一个session，可以省略-t参数 tmux kill-session -t 数字或名字：退出指定session tmux has-session -t 数字或名字：是否运行着指定session 内部操作 前缀（ctrl+s）+：\nc：新建window 数字：切换window编号 d：退出当前session，但不杀死（后台运行） n/p：切换到下一个/上一个window $：对当前session重命名 ,：对当前window重命名 \u0026：杀死当前session w：查看当前整体window层级结构 /：显示层级结构后，输入斜杠，进行进一步搜索 %：向右分屏 “：向下分屏 方向键：切换分屏 z：全屏/恢复当前分屏 x：关闭分屏（exit），当window的全部分屏退出后，自动关闭session { } ctrl+up ctrl+down：将当前pane移动到左/右/上/下 配置文件 在home目录新建~/.tmux.conf文件：\nset -g mouse on：开启鼠标支持（调整分屏大小） set -g prefix C-s：tmux默认前缀改为control+s bind | split-window -h -c “#{pane_current_path}\"：水平分屏到cwd bind - split-window -v -c “#{pane_current_path}\"：垂直分屏到cwd 启动脚本示例 #!/bin/bash # tmux 开发环境启动脚本 # 检查是否已经在 tmux 会话中 if [ -n \"$TMUX\" ]; then echo \"Error: Already in a tmux session\" exit 1 fi # 检查会话是否已存在 tmux has-session -t dev 2\u003e/dev/null if [ $? != 0 ]; then # 创建新会话 tmux new-session -d -s dev -n \"editor\" # 第一个窗口：代码编辑器 tmux send-keys -t dev:1 \"cd ~/projects/myapp\" Enter tmux send-keys -t dev:1 \"vim\" Enter # 创建第二个窗口：服务器 tmux new-window -t dev:2 -n \"server\" tmux send-keys -t dev:2 \"cd ~/projects/myapp\" Enter tmux send-keys -t dev:2 \"npm run dev\" Enter # 创建第三个窗口：数据库 tmux new-window -t dev:3 -n \"database\" tmux send-keys -t dev:3 \"docker ps\" Enter tmux send-keys -t dev:3 \"docker exec -it postgres psql -U user mydb\" Enter # 创建第四个窗口：日志 tmux new-window -t dev:4 -n \"logs\" tmux send-keys -t dev:4 \"cd ~/projects/myapp/logs\" Enter tmux send-keys -t dev:4 \"tail -f app.log\" Enter # 创建第五个窗口：系统监控 tmux new-window -t dev:5 -n \"monitor\" tmux send-keys -t dev:5 \"htop\" Enter # 水平分割第二个窗口（服务器窗口） tmux split-window -h -t dev:2 tmux send-keys -t dev:2.1 \"cd ~/projects/myapp\" Enter tmux send-keys -t dev:2.1 \"git status\" Enter # 设置初始窗口 tmux select-window -t dev:1 fi # 附加到会话 tmux attach -t dev 参考链接：\n# tmux 使用和基礎配置 從入門到加班 一個視頻全搞定！\n# Tmux + Vim 工作流! 同时操作多个项目, 追求极致的. 滑流畅! # Tmux has forever changed the wa. I write code.\n# you need to learn tmux RIGHT NO. !!",
    "description": "背景 全称terminal multiplexer 一个session可以包含多个子进程window，可以切换显示多个子进程 一个window又可以分割成多个分屏pane，方便编辑和后台运行任务 一个session保存了多个子进程信息，关闭terminal后可以重新恢复session 可以使用tmux运行长时间任务，后台运行防止关闭terminal导致杀死进程 可以在不同session、window和pane之间切换 使用说明 命令行操作 tmux：自动创建session tmux new -s 名字：创建命名session tmux ls：列出tmux全部session tmux a -t 数字：进入指定session，如果只有一个session，可以省略-t参数 tmux kill-session -t 数字或名字：退出指定session tmux has-session -t 数字或名字：是否运行着指定session 内部操作 前缀（ctrl+s）+：",
    "tags": [],
    "title": "Tmux使用教程",
    "uri": "/hugo-blog/blogs/tmux%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "Zapier官网 自动化流程配置工具，将你的多种不同的app的信息串联起来 gmail邮箱收到邮件，在whatsapp上设置bot提醒 stripe收到货款，导入google sheet新建一行 等等 支持AI辅助新建工作流 参考链接：\n# Zapier AI Tutorial for Beginners: Automation Made Simple 🟧",
    "description": "Zapier官网 自动化流程配置工具，将你的多种不同的app的信息串联起来 gmail邮箱收到邮件，在whatsapp上设置bot提醒 stripe收到货款，导入google sheet新建一行 等等 支持AI辅助新建工作流 参考链接：\n# Zapier AI Tutorial for Beginners: Automation Made Simple 🟧",
    "tags": [],
    "title": "Zapier",
    "uri": "/hugo-blog/blogs/zapier/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "这里汇总了不同的内容（主要是文档，如obsidian和notion中）整理方式\nACE Atlas：与时间无关的想法，笔记 Calendar：按时间例行化的内容，如日记、周记 Efforts：项目进度 参考链接：\n# Create Your Digital Home: Obsidian Walkthrough\nPARA Projects：项目进展，有时间节点限制，有任务要求 Areas：某一方面的计划和记录，不像projects那样有任物属性（时间节点或ddl），比如健康，某个领域的学习进展等 Resources：可以理解成与时间无关的ideas，例如blog、来自某本书的quote等 Archives：过时的内容，暂存 参考链接：\n# Organize Your ENTIRE Digital Life in Seconds (The PARA Method)",
    "description": "这里汇总了不同的内容（主要是文档，如obsidian和notion中）整理方式\nACE Atlas：与时间无关的想法，笔记 Calendar：按时间例行化的内容，如日记、周记 Efforts：项目进度 参考链接：\n# Create Your Digital Home: Obsidian Walkthrough\nPARA Projects：项目进展，有时间节点限制，有任务要求 Areas：某一方面的计划和记录，不像projects那样有任物属性（时间节点或ddl），比如健康，某个领域的学习进展等 Resources：可以理解成与时间无关的ideas，例如blog、来自某本书的quote等 Archives：过时的内容，暂存 参考链接：\n# Organize Your ENTIRE Digital Life in Seconds (The PARA Method)",
    "tags": [],
    "title": "内容整理方式",
    "uri": "/hugo-blog/blogs/%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86%E6%96%B9%E5%BC%8F/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "内容管理系统（CMS）方便记录各种信息，包括文章、想法、日程、计划等\nObsidian 优点 可以对笔记及内部元素进行双向连接，从而形成关系图谱 支持插件，包括built-in和自定义，例如图片上传等 支持自定义模版，方便新建笔记时快速初始化properties和格式 支持高级markdown格式，如callout等 数据本地化，方便离线操作 缺点 相比notion，缺少日程表类似的功能 不支持AI功能 参考链接：\n# 39分鐘上手Obsidian！基礎操作介紹（電腦、平板、手機全面教學）\n# Give Me 15 Minutes. I’ll Teach You 80% of Obsidian\nNotion 优点 页面UI丰富，支持各种拖拽、增减等操作 方便地进行任务规划，例如对database进行table或calendar格式的view 支持自定义模版，方便新建笔记时快速初始化properties和格式 支持丰富的页面可视化，例如icon等 支持团队协作编辑文档，可以给外部分享并评论 目前notion 3.0提供 Notion Agent的AI功能 缺点 对于纯粹的内容管理系统而言，功能冗余 对于每日行程规律的人友好，但反之就会有很多冗余操作 页面之间的关系是上下级，缺乏obsidian点对点的联系 可以通过@方式实现页面的跳转，但是不是概念（单词）粒度的联系 参考链接：\n# 全世界在学的软件，到底怎么用？Notion十分钟入门指南。 # How to Get Started with Notion (without losing your mind)\nNotion Agent 也称为notion 3.0，1.0为document，2.0为database，3.0加入AI agent 通过添加不同的agent为你工作，他们的工作包括：\n创建、查询和编辑database 创作和更新内容 在Notion、外部工具（如gmail、slack等）和网络中查询分析信息 参考链接：\n# Getting started with Notion Agent # Notion’s AI Agent is a Game-Changer (Notion made EASY!)",
    "description": "内容管理系统（CMS）方便记录各种信息，包括文章、想法、日程、计划等\nObsidian 优点 可以对笔记及内部元素进行双向连接，从而形成关系图谱 支持插件，包括built-in和自定义，例如图片上传等 支持自定义模版，方便新建笔记时快速初始化properties和格式 支持高级markdown格式，如callout等 数据本地化，方便离线操作 缺点 相比notion，缺少日程表类似的功能 不支持AI功能 参考链接：\n# 39分鐘上手Obsidian！基礎操作介紹（電腦、平板、手機全面教學）\n# Give Me 15 Minutes. I’ll Teach You 80% of Obsidian\nNotion 优点 页面UI丰富，支持各种拖拽、增减等操作 方便地进行任务规划，例如对database进行table或calendar格式的view 支持自定义模版，方便新建笔记时快速初始化properties和格式 支持丰富的页面可视化，例如icon等 支持团队协作编辑文档，可以给外部分享并评论 目前notion 3.0提供 Notion Agent的AI功能 缺点 对于纯粹的内容管理系统而言，功能冗余 对于每日行程规律的人友好，但反之就会有很多冗余操作 页面之间的关系是上下级，缺乏obsidian点对点的联系 可以通过@方式实现页面的跳转，但是不是概念（单词）粒度的联系 参考链接：\n# 全世界在学的软件，到底怎么用？Notion十分钟入门指南。 # How to Get Started with Notion (without losing your mind)",
    "tags": [],
    "title": "内容管理系统",
    "uri": "/hugo-blog/blogs/%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Weeklies",
    "content": "总结 学习notion基本功能，并基于notion搭建个人博客 学习css、html、javascript基础知识，搭建简单的github.io主页 基于notion + notion next + vercel搭建个人博客 调研notion建站方案 原生publish：直接点击页面的publish，notion原生样式 开源notion next： 通过next js实现notion内容拉取和前端渲染，可以定制化页面样式 参考链接 notion next fork仓库后可以修改配置 复制notion next作者的模版页面到自己的notion主页中，编辑内容进行博客编写 官网 vercel负责托管部署 关联github账号，import上述仓库，填写NOTION_PAGE_ID，部署 配置域名等与github pages类似 博客链接 学习css、html基础知识并简单搭建github.io css \u0026 html课程学习 课程链接 # 成為網頁設計師的第一步！快速上手 HTML \u0026 CSS 展開你的網頁設計之旅！ # HTML \u0026 CSS Full Course for free # HTML \u0026 CSS Full Course - Beginner to Pro html知识点 本质上就是和markdown一样的标记语言，用于给文本添加格式（markdown的设计是对应markup做的简化） 在html里可以直接添加css style，但是为了避免每个元素单独添加，可以将css文件提出来实现共用 css知识点 id：采用id的方式（比如\u003cp id=“p1”\u003e），可以用#（比如#p1） class：给元素在html里加上class，在css里面可以针对class加格式，比如.class combinators descendant：使用“ ”，对所有子节点加格式，比如.class p child：使用“\u003e” ，对儿子节点加格式（不包括孙子及更远下属） general sibling：使用“～”，兄弟节点 adjacent sibling：使用“+”，相邻兄弟节点 伪class：定义元素在特殊状态时的格式，比如： 悬浮：hover（li:hover，li:not(:hover)） 选中：active 某个：nth-child（li:nth-child(2)，li:nth-child(even)） 伪元素：对某一类元素加细粒度格式（比如p的第一行），可以用::（比如p::first-line、p::selection） span或者div（称为container）用来分组，从而对各组或整体进行排版 span是inline的，只对内容生效，div是block的，对整体block生效 通过nested layout技术组合横向或竖向（display设为block/inline-block）的div，得到几乎任意排版效果 padding就是字和border的距离，margin就是border和其他元素的距离 position： static：元素原本位置，不受left、right、top、bottom影响，也不作为上级给absolute做基准定位 relative：元素原本位置加上left、right、top、bottom的影响，多用于flex的下级元素 fixed：基于窗口（即browser view）作为基准定位的位置 absolute：基于上级（如果没有上级，即page）作为基准定位的位置 sticky：跟着scroll走 z-index：在html中的出现顺序决定了元素的默认渲染顺序，即后出现的在上面。可以通过设置z-index解决谁覆盖谁的问题（越大越靠上） grid：可以实现行列m x n布局，m和n也可以根据页面大小自适应调整 flexbox：可以方便地对container内部的元素进行动态的水平和垂直布局 可以解决两个div之间由于html换行导致的空格间隙 相比grid先定义行列再填充内容的方式，flexbox根据内容自动调整行列大小 transform：可以使对象旋转、缩放、变形等，会使用gpu加速，做动画场景时优先考虑 @media：考虑显示器的大小，实现相对应的不同样式，比如横向排版在宽度变小后改为纵向排版 @keyframes：利用transform、opacity、background-color等实现简单的动画效果 搭建简单静态网页 github.io 学习javascript基础知识 javascript课程学习 课程链接 # JavaScript 快速上手！用一個實戰範例迅速掌握所有重點語法！ javascript知识点 在body中加入script可以插入js代码，页面f12可以看到console.log的打印 通过在元素上添加listener来捕捉用户行为（点击、输入等），实现相应逻辑（如添加表单元素等） 知识 作为CMS，notion更偏向于项目管理，而obsidian更偏向于文档记录 待办 javascript基础知识 javascript进阶：ES6+新特性",
    "description": "总结 学习notion基本功能，并基于notion搭建个人博客 学习css、html、javascript基础知识，搭建简单的github.io主页 基于notion + notion next + vercel搭建个人博客 调研notion建站方案 原生publish：直接点击页面的publish，notion原生样式 开源notion next： 通过next js实现notion内容拉取和前端渲染，可以定制化页面样式 参考链接 notion next fork仓库后可以修改配置 复制notion next作者的模版页面到自己的notion主页中，编辑内容进行博客编写 官网 vercel负责托管部署 关联github账号，import上述仓库，填写NOTION_PAGE_ID，部署 配置域名等与github pages类似 博客链接 学习css、html基础知识并简单搭建github.io css \u0026 html课程学习 课程链接 # 成為網頁設計師的第一步！快速上手 HTML \u0026 CSS 展開你的網頁設計之旅！ # HTML \u0026 CSS Full Course for free # HTML \u0026 CSS Full Course - Beginner to Pro html知识点 本质上就是和markdown一样的标记语言，用于给文本添加格式（markdown的设计是对应markup做的简化） 在html里可以直接添加css style，但是为了避免每个元素单独添加，可以将css文件提出来实现共用 css知识点 id：采用id的方式（比如\u003cp id=“p1”\u003e），可以用#（比如#p1） class：给元素在html里加上class，在css里面可以针对class加格式，比如.class combinators descendant：使用“ ”，对所有子节点加格式，比如.class p child：使用“\u003e” ，对儿子节点加格式（不包括孙子及更远下属） general sibling：使用“～”，兄弟节点 adjacent sibling：使用“+”，相邻兄弟节点 伪class：定义元素在特殊状态时的格式，比如： 悬浮：hover（li:hover，li:not(:hover)） 选中：active 某个：nth-child（li:nth-child(2)，li:nth-child(even)） 伪元素：对某一类元素加细粒度格式（比如p的第一行），可以用::（比如p::first-line、p::selection） span或者div（称为container）用来分组，从而对各组或整体进行排版 span是inline的，只对内容生效，div是block的，对整体block生效 通过nested layout技术组合横向或竖向（display设为block/inline-block）的div，得到几乎任意排版效果 padding就是字和border的距离，margin就是border和其他元素的距离 position： static：元素原本位置，不受left、right、top、bottom影响，也不作为上级给absolute做基准定位 relative：元素原本位置加上left、right、top、bottom的影响，多用于flex的下级元素 fixed：基于窗口（即browser view）作为基准定位的位置 absolute：基于上级（如果没有上级，即page）作为基准定位的位置 sticky：跟着scroll走 z-index：在html中的出现顺序决定了元素的默认渲染顺序，即后出现的在上面。可以通过设置z-index解决谁覆盖谁的问题（越大越靠上） grid：可以实现行列m x n布局，m和n也可以根据页面大小自适应调整 flexbox：可以方便地对container内部的元素进行动态的水平和垂直布局 可以解决两个div之间由于html换行导致的空格间隙 相比grid先定义行列再填充内容的方式，flexbox根据内容自动调整行列大小 transform：可以使对象旋转、缩放、变形等，会使用gpu加速，做动画场景时优先考虑 @media：考虑显示器的大小，实现相对应的不同样式，比如横向排版在宽度变小后改为纵向排版 @keyframes：利用transform、opacity、background-color等实现简单的动画效果 搭建简单静态网页 github.io 学习javascript基础知识 javascript课程学习 课程链接 # JavaScript 快速上手！用一個實戰範例迅速掌握所有重點語法！ javascript知识点 在body中加入script可以插入js代码，页面f12可以看到console.log的打印 通过在元素上添加listener来捕捉用户行为（点击、输入等），实现相应逻辑（如添加表单元素等） 知识 作为CMS，notion更偏向于项目管理，而obsidian更偏向于文档记录 待办 javascript基础知识 javascript进阶：ES6+新特性",
    "tags": [
      "周记"
    ],
    "title": "Week3 个人博客搭建",
    "uri": "/hugo-blog/weekly/week3/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Blogs",
    "content": "OSI模型是计算机通信网络的抽象模型",
    "description": "OSI模型是计算机通信网络的抽象模型",
    "tags": [
      "技术笔记"
    ],
    "title": "OSI模型",
    "uri": "/hugo-blog/blogs/techs/osi%E6%A8%A1%E5%9E%8B/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Log \u003e First Day",
    "content": "first day things",
    "description": "first day things",
    "tags": [],
    "title": "First Day Things",
    "uri": "/hugo-blog/log/first-day/first-day-things/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Log",
    "content": "hello from third day",
    "description": "hello from third day",
    "tags": [],
    "title": "Third Day",
    "uri": "/hugo-blog/log/third-day/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Log",
    "content": "hello from second day",
    "description": "hello from second day",
    "tags": [],
    "title": "Second Day",
    "uri": "/hugo-blog/log/second-day/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Log",
    "content": "hello from first day",
    "description": "hello from first day",
    "tags": [],
    "title": "First Day",
    "uri": "/hugo-blog/log/first-day/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Weeklies",
    "content": "总结 域名注册 \u0026 图床搭建 尝试利用现有平台进行个人博客的搭建部署，不涉及具体框架或代码开发 学习obsidian基本功能 cloudflare域名注册 ruoruoliu.com，每年10刀左右 cloudflare账户 基于clodflare R2 + piclist搭建免费图床 由于picgo的S3插件上传有问题，替换为piclist 参考链接 基于hexo + github pages搭建个人博客 hexo主要是基于模版的页面生成和部署工具，可以命令行生成并部署到github pages中 每次修改source中的md文件，hexo在generate过程中更新public中对应的部分 github.io作为个人主页，对于仓库名有要求：ruoruoliu.github.io 页面搭建在github pages中的项目页面中： 博客链接 是否需要nginx解决网址栏输入最后没有/导致访问不同的问题？ 参考链接 基于obsidian + hugo + github pages搭建个人博客 hugo将md文件转化为html页面，并进行部署 调研hugo的theme，包括paper、paperMod、terminal和relearn 后续可以在博客更新过程中不断学习relearn基本功能： 主题官网 Obsidian编写md文件，hugo是和hexo类似的cms工具 处理obsidian的内部链接，转化为hugo可接受链接 使用obsidian插件“image auto upload”，插入图片时自动上传图床 通过obsidian插件“shell commands”一键同步文件到本地github目录： 参考链接， 插件连接，再push到github远程仓库，触发github pages更新部署 整体仓库push到main 网页代码通过”git subtree“ push到gh-pages分支 页面搭建在github pages中的项目页面中： 博客链接 知识 个人博客平台化搭建范式 内容编辑：通常是md格式，可以基于obsidian、notion等 内容到页面转化工具：hexo、hugo、nextjs等 服务托管平台：github pages、cloudflare pages、vercel等 待办 学习notion基本功能，并基于notion搭建个人博客 学习css、html、javascript基础知识",
    "description": "总结 域名注册 \u0026 图床搭建 尝试利用现有平台进行个人博客的搭建部署，不涉及具体框架或代码开发 学习obsidian基本功能 cloudflare域名注册 ruoruoliu.com，每年10刀左右 cloudflare账户 基于clodflare R2 + piclist搭建免费图床 由于picgo的S3插件上传有问题，替换为piclist 参考链接 基于hexo + github pages搭建个人博客 hexo主要是基于模版的页面生成和部署工具，可以命令行生成并部署到github pages中 每次修改source中的md文件，hexo在generate过程中更新public中对应的部分 github.io作为个人主页，对于仓库名有要求：ruoruoliu.github.io 页面搭建在github pages中的项目页面中： 博客链接 是否需要nginx解决网址栏输入最后没有/导致访问不同的问题？ 参考链接 基于obsidian + hugo + github pages搭建个人博客 hugo将md文件转化为html页面，并进行部署 调研hugo的theme，包括paper、paperMod、terminal和relearn 后续可以在博客更新过程中不断学习relearn基本功能： 主题官网 Obsidian编写md文件，hugo是和hexo类似的cms工具 处理obsidian的内部链接，转化为hugo可接受链接 使用obsidian插件“image auto upload”，插入图片时自动上传图床 通过obsidian插件“shell commands”一键同步文件到本地github目录： 参考链接， 插件连接，再push到github远程仓库，触发github pages更新部署 整体仓库push到main 网页代码通过”git subtree“ push到gh-pages分支 页面搭建在github pages中的项目页面中： 博客链接 知识 个人博客平台化搭建范式 内容编辑：通常是md格式，可以基于obsidian、notion等 内容到页面转化工具：hexo、hugo、nextjs等 服务托管平台：github pages、cloudflare pages、vercel等 待办 学习notion基本功能，并基于notion搭建个人博客 学习css、html、javascript基础知识",
    "tags": [
      "周记"
    ],
    "title": "Week2 个人博客搭建",
    "uri": "/hugo-blog/weekly/week2/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0 \u003e Weeklies",
    "content": "总结 完成科学上网环境搭建 完成远程开发环境搭建 科学上网配置 购买vps节点： 尝试了vultr和bandwagon两个服务商 vultr按小时收费，最低每月5刀，搬瓦工按quarter收费，三个月50刀 节点选择： 考虑是否支持运营商vip骨干网络，比如移动为cmi 搬瓦工可以使用日本节点，延迟控制在100ms以内，vscode响应时间可接受 参考链接 vscode remote配置 github copilot配置 免费试用 pro 1个月，后续切换到 free plan 后续可以尝试cursor以及claude code 知识 科学上网流程 购买vps节点 vps节点安装并配置代理客户端（s-ui）的tls 本地v2ray配置vps的tls 计算机网络 OSI模型 计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型” 待办 搭建个人博客，方便后续记笔记",
    "description": "总结 完成科学上网环境搭建 完成远程开发环境搭建 科学上网配置 购买vps节点： 尝试了vultr和bandwagon两个服务商 vultr按小时收费，最低每月5刀，搬瓦工按quarter收费，三个月50刀 节点选择： 考虑是否支持运营商vip骨干网络，比如移动为cmi 搬瓦工可以使用日本节点，延迟控制在100ms以内，vscode响应时间可接受 参考链接 vscode remote配置 github copilot配置 免费试用 pro 1个月，后续切换到 free plan 后续可以尝试cursor以及claude code 知识 科学上网流程 购买vps节点 vps节点安装并配置代理客户端（s-ui）的tls 本地v2ray配置vps的tls 计算机网络 OSI模型 计算机网络通讯的【系统性】扫盲——从“基本概念”到“OSI 模型” 待办 搭建个人博客，方便后续记笔记",
    "tags": [
      "周记"
    ],
    "title": "Week1 开发环境配置",
    "uri": "/hugo-blog/weekly/week1/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/hugo-blog/categories/index.html"
  },
  {
    "breadcrumb": "Ruoruoliu 2.0",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Projects",
    "uri": "/hugo-blog/projects/index.html"
  }
]

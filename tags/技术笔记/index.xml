<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术笔记 :: Tag :: Ruoruoliu 2.0</title>
    <link>https://ruoruoliu.github.io/hugo-blog/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ruoruoliu.github.io/hugo-blog/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>CSS学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/css%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/css%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>基础用法 id：采用id的方式（比如&lt;p id=“p1”&gt;），可以用#（比如#p1） class：给元素在html里加上class，在css里面可以针对class加格式，比如.class combinators descendant：使用“ ”，对所有子节点加格式，比如.class p child：使用“&gt;” ，对儿子节点加格式（不包括孙子及更远下属） general sibling：使用“～”，兄弟节点 adjacent sibling：使用“+”，相邻兄弟节点 伪class：定义元素在特殊状态时的格式，比如： 悬浮：hover（li:hover，li:not(:hover)） 选中：active 某个：nth-child（li:nth-child(2)，li:nth-child(even)） 伪元素：对某一类元素加细粒度格式（比如p的第一行），可以用::（比如p::first-line、p::selection） span或者div（称为container）用来分组，从而对各组或整体进行排版 span是inline的，只对内容生效，div是block的，对整体block生效 通过nested layout技术组合横向或竖向（display设为block/inline-block）的div，得到几乎任意排版效果 padding就是字和border的距离，margin就是border和其他元素的距离 position： static：元素原本位置，不受left、right、top、bottom影响，也不作为上级给absolute做基准定位 relative：元素原本位置加上left、right、top、bottom的影响，多用于flex的下级元素 fixed：基于窗口（即browser view）作为基准定位的位置 absolute：基于上级（如果没有上级，即page）作为基准定位的位置 sticky：跟着scroll走 z-index：在html中的出现顺序决定了元素的默认渲染顺序，即后出现的在上面。可以通过设置z-index解决谁覆盖谁的问题（越大越靠上） grid：可以实现行列m x n布局，m和n也可以根据页面大小自适应调整 flexbox：可以方便地对container内部的元素进行动态的水平和垂直布局 可以解决两个div之间由于html换行导致的空格间隙 相比grid先定义行列再填充内容的方式，flexbox根据内容自动调整行列大小 transform：可以使对象旋转、缩放、变形等，会使用gpu加速，做动画场景时优先考虑 @media：考虑显示器的大小，实现相对应的不同样式，比如横向排版在宽度变小后改为纵向排版 @keyframes：利用transform、opacity、background-color等实现简单的动画效果</description>
    </item>
    <item>
      <title>HTML学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/html%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/html%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>基础概念 HTML本质上 就是和markdown 一样的标记语言，用于给文本添加格式。&#xA;markdown的设计目标是对应markup做的简化版本&#xA;Canvas canvas创建 &lt;canvas width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;/canvas&gt; context 设置使用2D canvas，获取canvas的context，后续操作都是通过context</description>
    </item>
    <item>
      <title>Javascript学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/javascript%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/javascript%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>基础用法 ===：三个等号是全等，即对象类型和值均相等，两个等号只代表值相等 …：可变参数，比如function foo (a, b, …c)，c获取剩余可变参数 typeof：类型判断，如typeof xxx !== ‘function’ for循环： 对array（可迭代对象，包括map）可以用of for(ele of elements) {...} 对object属性可以用in for(property in element) {...} forEach函数接受的callback可以最多包含element、index、array三个参数 map函数相比forEach的区别：返回新的array；类似的还有filter reduce函数接受accumulator和element两个参数，最终返回一个element arrow function：一种函数定义的简化：() =&gt; … ()里面填参数，…填函数实现，多用于简单的one-liner fruits.forEach(fruit =&gt; console.log(fruit.calories)); this：使用当前对象作为this arrow function中的this的指向是代码位置确定的（词法定义域，Lexical Scope），而不是他被调用时确定的，因此在回调函数函数中可以绑定到当前对象（如果是普通函数作为回调函数，this在运行时才确定，已经和对象失联，只会绑定到global object） 可以用来实现constructor（ES6新特性支持class） super：使用父类方法 在子类中定义constructor时要首先使用父类的constructor，即super(xxx) setter和getter：用set和get关键字函数，定义class的私有属性的读写 外部只通过setter和getter读写私有属性，逻辑可控（比如类型检查） destructuring： 通过[]来解构array内容，例如swap a，b：[a,b] = [b,a] const elements = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]; // a = &#39;a&#39;, b = &#39;b&#39;, c = &#39;c&#39;, r = [&#39;d&#39;, &#39;e&#39;] const [a, b, c, ...r] = elements; 通过{}来解构object内容，可以在function的参数使用这个方式 function displayPerson({firstname, lastname}) { console.log(firstname); console.log(lastname); } sort：默认情况按lexicographic（字母+数字+符号）排序，即1、10、2、3… 可以添加cmp：numbers.sort((a,b) =&gt; a - b)，来进行数字排序 string属性不能用减法，转成NAN后都相等，需要a.name.localeCompare(b.name) shuffle：没有内置的shuffle，需要自己实现Fisher-Yates算法 setTimeout：等待一段时间（毫秒）后执行函数，可以通过clearTimeout取消 异常捕获： 使用try、catch、finally拦截异常 使用throw new Error()抛出异常 修改html： 添加三部曲：构建element、添加属性、插入DOM（基于父节点） 删除：removeChild，基于父节点 事件监听：eventListener 监听click、mouseover、mouseout、keydown、keyup事件 .addEventListener(event, callback) 可以通过DOMContentLoaded事件来等待dom加载完成后再加载图片 classList：通过api访问className，来修改元素的css类，相当于通过js给页面动态加样式 支持add、remove、toggle、replace、contains操作 JSON：stringify和parse实现js obect和json string的相互转换 fetch：异步函数，通过路径（本地或远程连接）读取数据 Module module：代码通过模块载入，类似python的import 在html的script标签里加上type=“module”，将index.js当作module载入 变量和函数前需要加上export关键字 在index.js头部加上import {变量名、函数名} from ‘文件路径’ 异步 setTimeout就是一个异步函数的例子，不阻碍主线程 一般通过callback、promise、async/await实现 当使用callback来串联异步函数时，会出现callback hell现象，即callback嵌套过度让代码可读性变差，可以通过promise或者async/await解决 promise：用来管理异步操作的对象 异步函数foo()返回promise对象，new Promise((resolve, reject)) =&gt; {异步逻辑} 用.then来承接异步函数，即foo().then(value =&gt; {…})，then里面写resolve处理逻辑 resolve函数可以返回另一个promise，用来串联下一个异步函数 用.catch来承接异步函数，即foo().catch(error =&gt; {…})，catch里面写reject处理逻辑 reject函数指定失败的逻辑，对整体异步链生效，无法针对其中的某个异步函数单独指定reject 如果想对某个异步函数实现单独失败处理，有如下两种方案： 方法一：.then中加入(error =&gt; {…})的部分 方法二：在异步函数中的reject参数中给出类型，在后续统一的catch中按类型实现单独逻辑 async/await：用同步的方式写异步 async让一个函数返回promise 是个语法糖，自动将函数返回结果包装在Promise.resolve()中 await让一个异步函数等待一个promise 通过写一个async关键词的函数来包含多个异步函数，每个异步函数用await来等待结果，用try/catch来捕获异步过程中的error，可以将上述promise的链式调用改写为同步风格的函数： function bar() { return new Promise((...)) } function fuz() { return new Promise((...)) } async function foo() { xxx = await bar(); yyy = await fuz(); } DOM的概念 DOM：Document Object Model 浏览器加载html构建DOM，将元素以树形结构展示 javascript可以通过DOM动态改变网页的内容、结构和样式 动态（live）获取，指查询后的改变能实时更新，类似于引用： getElementById：精准获取element getElementsClassName返回html collection，注意不等同于array，比如不支持forEach操作，可以用Array.from(XXX)来转化为array getElementsByTagName返回所有tag（如h2）下面的html collection 静态（static）获取，指查一次，子元素不再改变，类似于快照、拷贝： querySelector/querySelectorAll通过类似css的获取方式（./#） querySelector获取第一个element querySelectorAll获取nodelist，一般用forEach遍历 可以用console.dir(document)来显示结构 ES6新特性 let和const替代var： 明确的块级作用域， 避免变量提升（hoisting），鼓励先声明后使用 防止重复声明（var可以重复声明，后者覆盖前者） 引入const，var不具有const的属性 this：指向对象本身 只有在对象调用的时候才指向对象，否则指向global object（window） 可以通过bind将函数手动绑定到对象上来正确使用this 异步函数的回调函数中的this，不会自动绑定到对象上，需要使用arrow函数或者手动绑定 const person = { name: &#39;Alice&#39;, talk() { // 箭头函数继承了外部 talk() 的 this (即 person) setTimeout(() =&gt; { console.log(&#34;this&#34;, this); // 输出: person }, 1000); } }; person.talk(); 解构： 同名结构，如果需要重命名，可以 address = { &#34;a&#34;: 1, &#34;b&#34;: 2 } const {a: e, b: f} = address // 这样 e 的值才是 address.a (即 1) …： 可以展开array，例如a.concat(b)等价于[…a, …b]，展开object，例如{…a, …b} 同样的可以用来clone array class： 预留constructor关键字作为构造函数名，类似之前的首字母大写的同名函数 继承：class b extends a { … }，需要在constructor中调用super() module： 对外部需要调用的class/function加上export关键字 named：export class a { … } default：export default class a { … } 对内部需要使用的部分进行import， named：import { a } from ‘文件路径’ default：import a from ‘文件路径’ 命名（named）导出和默认（default）导出： 命名导出只能有一个，而命名导出可以多个，import a, { b, c, d } from ‘文件路径’ 在html文件中需要标记&lt;script type=‘module’ src=‘index.js’&gt;&lt;/script&gt; 面向对象 OOP的四大基本原则： encapsulation（封装）：对象的内部函数可以将属性用this关键词使用 abstraction（抽象）：定义接口，隐藏内部逻辑和变量 inheritance（继承）：减少重复代码 polymorphism（多态）：不同的子类对于相同函数签名的实现 构造函数： 函数名首字母大写，内部属性用this表示，隐式返回this 调用使用new关键字，否则当作普通函数对待 对象的属性可以随时增减，因为本质就是一个{} 可以用obj[‘xxx’] = yyy来新增属性（正常是obj.xxx = yyy），这样属性名可以不用写死 delete关键字删除属性 基本类型按值拷贝，对象（{}、函数、Array）按引用拷贝 函数内用let定义私有属性，防止外部使用 getter/setter： 通过Object.defineProperty来实现 Object.defineProperty(this, &#39;xxx&#39;, { get: function() { return xxx; }, set: function(value) { if (value is valid) xxx = value; } }) 或者直接定义set，get class Example { constructor(value) { this._value = value; // 约定：内部存储属性 } // 公共接口：控制对属性的访问 get value() { return this._value; } set value(newValue) { this._value = newValue; } } 包管理 npm npm init在项目中来创建package.json –yes（-y）直接默认 package.json的作用： 管理项目依赖 scripts中支持脚本运行初始化构建项目 package-lock.json：由于不同时间npm install的包版本不一致，需要用这个文件来固定版本，保证不同人安装同样的版本 npm install安装依赖，创建node_modules目录存放 –save（-S）可以自动在package.json中记录 –save-dev（-D）表示只用于develop，不用于production -g：全局（global）安装，不会出现在package.json中，可以命令行执行，例如live-server @X.X.X：安装指定版本 ^X.X.X指保持大版本，小版本和patch更新到最新 ~X.X.X指保持大版本和小版本，patch更新到最新 *指更新到最新 npm list列出项目依赖 –depth 0，不显示子依赖，1，显示一级子依赖 –global true，显示全局安装 npm update更新依赖到指定的最新版本 npm prune删除package.json中不存在的已安装依赖 npm run运行package.json中scripts指定的命令 参考链接： npm Tutorial for Beginners # NPM Full Course For Beginners - Learn NPM fundamentals and basics 扩展阅读 javascript游戏编程 Javascript Game Development Masterclass 2022</description>
    </item>
    <item>
      <title>像素工具Asperite</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/%E5%83%8F%E7%B4%A0%E5%B7%A5%E5%85%B7asperite/index.html</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/%E5%83%8F%E7%B4%A0%E5%B7%A5%E5%85%B7asperite/index.html</guid>
      <description>官网链接</description>
    </item>
    <item>
      <title>游戏编程基本概念</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/index.html</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/index.html</guid>
      <description>Game Loop Game Loop的结构通常是以下三步的循环： Process Input Update Game State Draw Game 参考链接： Game Programming Patterns # Game States and Game Loops # Getting The Game Loop Right 扩展阅读</description>
    </item>
    <item>
      <title>从零开始构建Flappy Bird</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAflappy-bird/index.html</link>
      <pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAflappy-bird/index.html</guid>
      <description>背景 在完成css、html、javascript的基础上，构建Flappy Bird游戏，以巩固以上知识点 预备知识： HTML学习手册-Canvas 游戏编程基本概念-Game Loop Flappy Bird Game Loop Flappy Bird的游戏逻辑设计 home：主页，显示标题和两个button（start、score），目前只实现了start ready：主页点击start进入ready页面，给出游戏提示“tap” play：在ready页面tap后进入游戏页面，包含： 初始化：小鸟、pipe和实时分数 监听用户tap： 没有tap的话有向下加速度，模拟重力 有tap行为则直接给一个向上的速度 记分：小鸟每次经过一个pipe，score加1，score超过best则覆盖best 结束：小鸟和pipe的碰撞检测，碰到上下边缘或者pipe则结束，进入结束页面 over： 结束页面显示记分牌，显示奖牌（是best则金牌，不然白牌），显示score和best 给出ok和menu按钮，其中ok回到ready页，menu回到home页 技术细节 精灵图集 Sprite 精灵图集将游戏中所有的小图片（如小鸟、管道、背景、按钮等）集中在一个大文件里 在网页中获取的时候，可以使用CSS Sprites技术：使用 background-image 和 background-position 两个属性来在网页元素中显示精灵图集上的某一个图标或图片 可以使用 Sprite Cow对精灵图集进行分割处理，得到每个图标的position 注意图标推荐放在div或者span中，而不是img中 如何实现游戏基本逻辑 利用requestAnimationFrame（简单来说，rAF告诉浏览器：“我要执行一个动画，请在下一次重绘（Repaint）之前调用我的回调函数。”），将Game Loop函数作为callback，从而不断刷新游戏状态，实现元素的移动，以及整体Game Loop function GameLoop() { //移动小鸟 ... // 更新游戏分数 updateGameScore(); // 更新pipes的状态 updatePipes(); // 边界碰撞检测 if (birdPosY &lt; 0 || birdPosY + 22 &gt; 400) { console.log(&#34;Hit Boundary&#34;); game_state = &#34;ended&#34;; } // pipe碰撞检测 ... if (game_state === &#34;ended&#34;) { ... console.log(&#34;Game Over!&#34;); return; } requestAnimationFrame(GameLoop); } 如何实现背景的移动 css中将背景设置为精灵图集中的一部分，且repeat-x，水平循环 #scene { position: relative; /* 改为相对定位，由 flex 控制居中 */ border: 5px solid red; box-sizing: border-box; /* 让 border 包含在宽高内 */ display: flex; align-items: center; justify-content: center; flex-direction: column; background: url(&#39;../images/flappy-bird-sprite.png&#39;) repeat-x 0 0; image-rendering: pixelated; width: 225px; /* 原始宽度 */ height: 400px; /* 原始高度 */ overflow: hidden; /* 确保内容不溢出游戏画面 */ } 在js中设置scene的backgroundPostion可以整体移动 scene.style.backgroundPosition = `-${backgroundX}px 0px`; 如何实现小鸟的移动 水平方向上不移动，固定在屏幕30%位置上 #bird { position: absolute; background: url(&#39;../images/flappy-bird-sprite.png&#39;) no-repeat -179px -513px; width: 28px; height: 22px; top: 200px; left: 30%; transform: translateX(-50%); } 垂直方向上，根据游戏逻辑，确定位置后，通过top来实现移动 // 重力加速度下降 birdSpeedY += 0.1; birdPosY = birdPosY + birdSpeedY; bird.style.top = `${birdPosY}px`; 如何实现小鸟扇动翅膀 对于小鸟这个div，根据时间不断切换精灵图集中的backgroundPosition，从而切换不同图片 // 小鸟扇翅膀动画 birdFrameTimer++; if (birdFrameTimer % birdWingRate === 0) { // 每10帧切换一次图片，数字越小越快 birdFrameIndex = (birdFrameIndex + 1) % birdFrames.length; bird.style.backgroundPosition = birdFrames[birdFrameIndex]; if (birdFrameTimer === birdWingRate) { birdFrameTimer = 0; } } 如何实现管道的平移 在html中写三组pipe元素 在js中通过transform水平移动，如果移动超过屏幕，则从最左侧重置到最右侧 // 如果移出屏幕左侧，移动到最右侧 if (pipe.x &lt; -pipeWidth) { // 找到当前最右边的管道的 x 坐标 let maxX = Math.max(...pipesData.map(p =&gt; p.x)); pipe.x = maxX + pipeDistance; // 重新随机高度 pipe.y = Math.floor(Math.random() * (300 - 100)) + 100; pipe.scored = false; } 如何实现页面切换 在html中写在一起 &lt;div id=&#34;scene&#34;&gt; &lt;!-- 首页场景 --&gt; &lt;div id=&#34;scene_home&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏准备场景 (默认隐藏) --&gt; &lt;div id=&#34;scene_ready&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏场景 (默认隐藏) --&gt; &lt;div id=&#34;scene_play&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏结束场景（默认隐藏）--&gt; &lt;div id=&#34;scene_over&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;/div&gt; 然后通过在js中设定某一个部分（div）的display是否为none，来切换显示不同部分 document.getElementById(&#34;ok_button&#34;).addEventListener(&#39;click&#39;, function(){ // 隐藏首页场景 document.getElementById(&#34;scene_over&#34;).style.display = &#39;none&#39;; // 隐藏游戏层 document.getElementById(&#34;scene_play&#34;).style.display = &#39;none&#39;; // 显示游戏场景 document.getElementById(&#34;scene_ready&#34;).style.display = &#39;flex&#39;; // 游戏状态进入ready game_state = &#34;ready&#34;; }); 代码仓库 github链接： flappy-bird</description>
    </item>
    <item>
      <title>LLM Agent</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/llm-agent/index.html</link>
      <pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/llm-agent/index.html</guid>
      <description></description>
    </item>
    <item>
      <title>Context Rot</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/context-rot/index.html</link>
      <pubDate>Fri, 28 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/context-rot/index.html</guid>
      <description>参考链接：&#xA;Context Rot: How Increasing Input Tokens Impacts LLM Performance</description>
    </item>
    <item>
      <title>OSI模型</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/osi%E6%A8%A1%E5%9E%8B/index.html</link>
      <pubDate>Sat, 15 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/osi%E6%A8%A1%E5%9E%8B/index.html</guid>
      <description>OSI模型是计算机通信网络的抽象模型</description>
    </item>
  </channel>
</rss>
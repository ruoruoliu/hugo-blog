<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术笔记 :: Tag :: Ruoruoliu 2.0</title>
    <link>https://ruoruoliu.github.io/hugo-blog/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 Feb 2026 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ruoruoliu.github.io/hugo-blog/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LangChain学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/langchain%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 06 Feb 2026 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/langchain%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>Agents 通过create_agent函数创建，底层通过LangGraph实现基于图的agent运行时，图包含节点（node）和边（edge），agent在节点间移动，包括model、tools和中间件 核心组件包括：&#xA;Model： 支持静态模型，即初始化固定后，交互过程中不变 支持动态选择的，可以使用wrap_model_call中间件，基于请求拦截并override模型 Tools： 多工具串行调用、工具并行调用 基于之前结果的工具动态选择 工具的错误重试和处理逻辑：使用wrap_tool_call中间件 保持工具调用之间的状态一致 动态工具：即在运行过程中进行工具变更，包括： 根据当前状态和上下文，利用wrap_model_call中间件动态筛选已注册工具，这种方式适用于所有工具在创建agent时已明确 如果工具是运行时动态发现的，比如来自MCP server、用户数据等，需要运行时注册工具，包括添加（wrap_model_call）和处理（wrap_tool_call）逻辑 System prompt： 可以接受str或者SystemMessage类型（支持claude的prompt caching） 通过dynamic_prompt中间件基于request修改system prompt Invocation： state就是message的序列，通过invoke来输入一条新的message 可以通过stream触发流式输出 高级概念：&#xA;Structured output 通过response_format对agent的回复进行格式化： 使用ToolStrategy对一个结构化数据格式进行包装，利用模型tool的能力来进行格式化 如果模型支持native structured output，可以直接使用ProviderStrategy进行包装 Memory： agent本身通过State（message序列）记录对话过程，可以通过以下方式扩展memory： 定义基于AgentState的扩展state，再通过中间件（比如内部的before_model的hook）实现state的修改，这种方式可以把逻辑和所需要的工具绑定在state修改的时刻，而不用在create_agent的时候绑定 定义基于AgentState的扩展state，传入state_schema字段，只适合大模型直接通过工具（而不是中间件）访问的memory，不够可控 Middleware： 在模型调用前：message裁剪、上下文注入 修改或者验证模型输出：guardrails和内容过滤 处理工具调用失败 基于state或者context进行动态模型选择 加入定制化log、监控和分析 Models Model的常见使用：</description>
    </item>
    <item>
      <title>LangGraph学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/langgraph%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Wed, 04 Feb 2026 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/langgraph%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>LangGraph是一个底层的agent编排工具&#xA;from langgraph.graph import StateGraph, MessagesState, START, END def mock_llm(state: MessagesState): return {&#34;messages&#34;: [{&#34;role&#34;: &#34;ai&#34;, &#34;content&#34;: &#34;hello world&#34;}]} graph = StateGraph(MessagesState) graph.add_node(mock_llm) graph.add_edge(START, &#34;mock_llm&#34;) graph.add_edge(&#34;mock_llm&#34;, END) graph = graph.compile() graph.invoke({&#34;messages&#34;: [{&#34;role&#34;: &#34;user&#34;, &#34;content&#34;: &#34;hi!&#34;}]}) 参考链接：&#xA;LangChain Docs: LangGraph</description>
    </item>
    <item>
      <title>Python学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/python%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Wed, 04 Feb 2026 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/python%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>TypedDict 通常的字典类型无法限制dict的key字段：&#xA;type User = dict[str, str | int] bob: User = {&#39;job&#39;: &#39;chef&#39;, &#39;wage&#39;: 1000} TypedDict帮助限制dict的字段结构:&#xA;from typing import TypedDict, Required, NotRequired, ReadOnly class User(TypedDict, total=False): name: ReadOnly[str] age: int email: Required[str] TypeDict的使用方式：&#xA;TypedDict可以嵌套 TypedDict中的成员名称要和dict中的key一致，包括大小写 total字段设置False表示某些字段是optional的 可以使用Required和NotRequired表示字段级别的是否必需 可以使用ReadOnly表示某个字段是否只读 注意：上述如果不符合要求，只会警告提示，不会报错&#xA;参考链接：&#xA;# TypedDict is Awesome in Python Pydantic 相比TypedDict的约定形式，Pydantic是更严格的运行时格式校验，是dataclass的第三方强化版，通常用于构建健壮的API、配置和复杂数据模型</description>
    </item>
    <item>
      <title>LLM推理技术学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/llm%E6%8E%A8%E7%90%86%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Tue, 20 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/llm%E6%8E%A8%E7%90%86%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>Latency KV Cache 在 Transformer 的 Self-Attention 层中，计算公式为： $$\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V$$ 其中：&#xA;Q (Query)：代表当前的字 K (Key) &amp; V (Value)：代表上下文的信息 由于前面的计算结果已经算完，可以直接存在显存里，方便解码时快速使用：&#xA;Prefill（预填充）阶段：模型处理你输入的 Prompt，计算出所有已存在字符的K和V，并把它们存在显存里 Decoding（解码）阶段：每生成一个新词，模型只需要计算这个新词的K和V，然后直接从显存里读取之前存好的K和V进行拼接，计算Attention KV Cache让生成每个新词的时间复杂度从 $O(n^2)$ 降低到了 $O(n)$，但是显存占用很高，并随着序列长度增长而线性增加，另外传统的显存分配方式会导致很多浪费（类似磁盘碎片），这也是为什么后来出现了vLLM (PagedAttention)技术来优化它&#xA;PD分离 由于Prefill阶段是计算密集型，而Decoding阶段时访存密集型，因此如果用同一种类型的显卡进行两个阶段，对导致在Prefill阶段对显存的浪费和在Decoding阶段对计算能力的浪费，因此将两阶段分离，分开部署在不同的显卡上：</description>
    </item>
    <item>
      <title>Reinforcement Learning学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/reinforcement-learning%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Thu, 15 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/reinforcement-learning%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>基础知识 Markov Decision Process Bellman Optimality Equation Model-Free Prediction &amp; Control SARSA Q-Learning Value Function Approximation DQN Policy Gradient Actor-Critic Exploitation &amp; Exploration 参考链接:&#xA;DeepMind x UCL Introduction to RL 2015 课程笔记 Value-based DQN Target Network 为了避免Q-learning中Bootstrapping带来的模型追逐变化的目标导致训练不稳定的情况，DQN引入了两套结构完全一样、但参数不同的网络：</description>
    </item>
    <item>
      <title>DeepMind x UCL Introduction to RL 2015 课程笔记</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/deepmind-x-ucl-introduction-to-rl-2015-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html</link>
      <pubDate>Fri, 09 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/deepmind-x-ucl-introduction-to-rl-2015-%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html</guid>
      <description>Intro 强化学习与机器学习的差别：&#xA;没有supervisor，只有reward 反馈是滞后的，不是实时的 时间序列，每一个时间步不是i.i.d的 agent的行为会影响后续数据 reward是什么：&#xA;一个标量的反馈信号 表示agent在t时刻的表现 agent的目标是最大化累积reward 序列决策是什么：&#xA;目标是选择action，最大化累积reward action有长期的影响，因为reward是滞后的，意味着可能需要牺牲短期reward来获取长期reward 序列H包含observation、action、reward的循环：O1、A1、R1、O2、A2、R2、… state是什么：&#xA;state是序列的函数，即当前的状态包含了观察、行为、奖励序列的全部信息 environment state是指环境的内部状态表示，通常是agent不可见的；即使可见，也通常包含一些不相关的噪音 agent state是agent的内部状态表示，作为下一次action选择的输入，也可理解为RL算法的输入 markov state是指包含之前全部信息的当前状态，只依赖于当前状态，与之前状态独立 在完全可观测环境中，agent state等于environment state，构成MDP（markov decision process）；在部分可观测环境中，agent state不等于environment state，构成POMDP（partially observable markov decision process） agent agent的组成：</description>
    </item>
    <item>
      <title>LLM训练技术学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/llm%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Mon, 05 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/llm%E8%AE%AD%E7%BB%83%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>LLM训练主要包含三部分：&#xA;Pre-training：通过大量互联网文本数据，训练base model SFT：通过人工标注对话预料进行微调，让base model掌握对话（ai assistant）能力 RLHF：通过强化学习让模型知道人类偏好，什么是好的回复，什么是不好的回复 参考链接：&#xA;# Deep Dive into LLMs like ChatGPT Pre-training 利用大量文本序列，通过预测下一个token的任务训练，得到基座模型（base model），此时模型具备序列文本生成能力&#xA;DeepSeek MTP 训练过程中通过多个head同时预测后续多个token，强迫模型预测长期未来 预测的时候，MTP作为 投机解码的提议者，由MTP生成n个token，然后主干模型再计算是否正确，即符合主干模型的概率分布，如果正确则保留，不正确则抛弃，以此循环 MTP像一个滑动窗口在每个主干模型截止的位置发起下一次多token预测 MTP可以比主干模型小一些，但整体速度收益还是在于多token的并发预测 接受MTP结果的判断通常使用拒绝采样来完成 投机解码中使用拒绝采样判断是否接受 投机解码中使用拒绝采样的修正逻辑 # 为什么LLM投机推理小模型被拒绝后要从修正分布获取正确的token？ 参考链接：</description>
    </item>
    <item>
      <title>从零开始构建商品收货系统</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E5%95%86%E5%93%81%E6%94%B6%E8%B4%A7%E7%B3%BB%E7%BB%9F/index.html</link>
      <pubDate>Mon, 05 Jan 2026 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E5%95%86%E5%93%81%E6%94%B6%E8%B4%A7%E7%B3%BB%E7%BB%9F/index.html</guid>
      <description>背景 需求：老家亲戚是做衣服加工的，分为横机和套口两个种类，现在要做一个功能，来汇总和清晰的展示一些统计数据 现状：目前使用excel来完成：图1包含了横机的单位重量（重量/件）、施工单位和套口的施工单位的基础信息；图2包含了横机按时间、施工单位、件数、重量（件数 * 重量/件）的明细；图3包含了套口按时间、施工单位、件数（包含发出和收回）的明细 痛点：亲戚目前每天手动填写当天的新增条目（哪个单位给了多少，什么款式，如果是套口还包含收回多少），然后需要下拉excel单元格显示结果（excel的列目前用公式指定怎么计算结果）。现在希望可以只用手动添加条目，不用excel下拉的方式，且统一品类在同一页面方便截图 想法：做一个网页，加一个后台数据库，直接访问网页操作，但是考虑数据隐私和亲戚电脑没有联网的情况，设计为本地保存数据 整体思路 基于上述要求，gemini的思路： 方案二细节： 从零开始构建商品收货系统-方案细节&#xA;具体实现 代码链接 product-record-manager</description>
    </item>
    <item>
      <title>LLM进展与应用</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/llm%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8/index.html</link>
      <pubDate>Wed, 31 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/llm%E8%BF%9B%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8/index.html</guid>
      <description>应用 NLP #todo langextract&#xA;推荐 产品 对话助手 Perplexity Claude Gemini Kimi Kimi K2.5 参考链接：</description>
    </item>
    <item>
      <title>长程任务：Deep Agent</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/%E9%95%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1deep-agent/index.html</link>
      <pubDate>Sat, 27 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/%E9%95%BF%E7%A8%8B%E4%BB%BB%E5%8A%A1deep-agent/index.html</guid>
      <description>什么是长程任务 长程任务（Long-horizon tasks）任务通常包含数十步甚至上百步的推理与操作，且往往涉及跨软件交互、长时间跨度和不确定的环境反馈&#xA;Deep Agent Deep Agent一般认为由四部分组成：&#xA;planning tool：前期任务规划 将计划写入文件，标注状态（pending/working/finished） 后续更新状态，并在最终所有计划中的step完成时，结束任务 sub agents： 防止占用主agent的context 拥有专家能力 能力可复用 灵活的权限管理 file system：通过文件系统扩充context 与外部的交互通常token巨大，如web的html数据、pdf等 context过长容易导致模型能力衰减 context过长带来的成本问题 system prompt： 通常很长（几百甚至上千行）且很详细，结构清晰 包含few-shot prompt tool使用规范，包含好的和坏的使用样例 参考链接：&#xA;# What are Deep Agents? # Implementing deepagents: a technical walkthrough # Build AI Agents That Work While You Sleep | Deep Agents Human-in-the-loop 在长程任务中的三大作用：</description>
    </item>
    <item>
      <title>Agent学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/agent%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 26 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/agent%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>Agent整体概括 Agent和workflow的主要区别在于，workflow的工作流是用户预定义好的，而Agent基于用户目标自己探索工作流。Agent的优势在于给予模型自由度，从而当模型的能力提升时，Agent的能力也会随着提升 Generative Agents通过在虚拟环境中多个agent的交互，证明拥有plan、reflect和memory能力的agent可以更好的作出符合人类共识的判断 Agent的四个核心部分：LLM + 规划 + 记忆 + 工具使用 参考链接：&#xA;# Building effective agents A practical guide to building agents # LLM Powered Autonomous Agents Planning COT</description>
    </item>
    <item>
      <title>Context Engineering学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/context-engineering%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Wed, 24 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/context-engineering%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>Context Rot 虽然大模型上下文窗口的上限不断增加，但任性的塞满上下文窗口其实反而会带来回复效果的损失，造成context rot现象 参考链接：&#xA;Context Rot: How Increasing Input Tokens Impacts LLM Performance # How Long Contexts Fail Context Engineering 大模型回复的context应该包含以下几方面： system prompt：系统提示词，回复的高级指导 long-term/short-term memory：长短期，用户对话过程中对后续有用的关键信息 RAG：外部参考数据 tools：工具返回数据 structured output：回复的格式要求 user prompt：用户的上文</description>
    </item>
    <item>
      <title>RAG学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/rag%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Wed, 24 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/rag%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>RAG Retrieval-Augmented Generation 通过检索获取实时信息，补充模型预训练阶段缺失的知识 需要在两方面确保RAG能真正提升效果： retriever检索到的信息是高度相关且正确的 generator能辨别retriever提供信息的可靠性和正确性，或者抛弃检索信息 参考链接：&#xA;../Answers/2025年RAG技术回顾与展望 CAG CAG（cache-augmented）通过将目标文档全文塞进prompt中，避免RAG中检索不精准的问题，目标文档通过kv-cache的方式预先计算，减少推理开销 关于CAG的存在意义以及其局限性： ../Answers/CAG的存在意义以及其局限性 参考链接：&#xA;# RAG vs. CAG: Solving Knowledge Gaps in AI Models GraphRAG</description>
    </item>
    <item>
      <title>MCP和Skills</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/mcp%E5%92%8Cskills/index.html</link>
      <pubDate>Mon, 22 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/mcp%E5%92%8Cskills/index.html</guid>
      <description>MCP model context protocol在2024年底由anthropic开源， 用于方便大模型agent获取和操作内部数据或者外部API接口 MCP规定了MCP client（agent）和MCP server上的tool、resource、prompt之间的交互协议 MCP中的分工： MCP server MCP server的实现，以python版本github的list_repo_issues为例： from mcp.server.fastmcp import FastMCP import httpx import os # 1. 初始化 FastMCP # name 会显示在 AI 客户端中 mcp = FastMCP(&#34;GitHub Manager&#34;) # 从环境变量获取 Token GITHUB_TOKEN = os.getenv(&#34;GITHUB_TOKEN&#34;) # 2. 定义一个工具 (Tool) # FastMCP 会根据函数签名、类型提示和 Docstring 自动生成 MCP 所需的 Schema @mcp.tool() async def list_repo_issues(owner: str, repo: str) -&gt; str: &#34;&#34;&#34; 获取指定 GitHub 仓库的公开 Issue 列表。 :param owner: 仓库所有者 (例如 &#39;psf&#39;) :param repo: 仓库名称 (例如 &#39;requests&#39;) &#34;&#34;&#34; url = f&#34;https://api.github.com/repos/{owner}/{repo}/issues&#34; headers = { &#34;Authorization&#34;: f&#34;token {GITHUB_TOKEN}&#34;, &#34;Accept&#34;: &#34;application/vnd.github.v3+json&#34; } async with httpx.AsyncClient() as client: response = await client.get(url, headers=headers) response.raise_for_status() issues = response.json() # 格式化输出给 AI 看 results = [] for issue in issues[:10]: # 仅取前10个 results.append(f&#34;#{issue[&#39;number&#39;]}: {issue[&#39;title&#39;]}&#34;) return &#34;\n&#34;.join(results) if results else &#34;没有找到打开的 Issue。&#34; if __name__ == &#34;__main__&#34;: # 3. 启动 Server（默认使用 stdio 传输） mcp.run() MCP server的配置 { &#34;mcpServers&#34;: { &#34;my_python_github&#34;: { &#34;command&#34;: &#34;python3&#34;, &#34;args&#34;: [&#34;/你的绝对路径/github_server.py&#34;], &#34;env&#34;: { &#34;GITHUB_TOKEN&#34;: &#34;你的_PERSONAL_ACCESS_TOKEN&#34; } } } } MCP Host（client） MCP Host会把各个的大模型工具调用json转换为统一的MCP格式调用json，并在MCP server中进行调用（server通常是在Host本地起的一个子进程），从而用户只要关心MCP上不同工具的配置参数即可，不同厂家的模型都可以无缝使用这些工具 MCP Host开始只是大模型厂商在做，逐渐演变成编辑器（IDE）、容器（docker）等加入，只要支持对json的翻译能力就可以 MCP Host初始化 会进行工具查询，与配置文件里的所有 MCP Server 进行“握手” 当你开启一个“新对话”并输入第一句话时，Host 会把缓存里的工具定义转换成模型能懂的格式，塞进system prompt 专业的host甚至在每一轮对话都会传入，以便模型维持记忆，并进行动态筛选+缓存（prompt caching） MCP Gateway 使用MCP网关可以帮我们减少在host上的mcp server的配置工作，简单说就是只用配置一个MCP server，即MCP网关，而MCP网关内部帮我们配置了多个MCP server 如果后续切换Host，或者你有多个Host，也不用重新设置一遍配置，或者在多个Host修改配置 这种网关比如docker desktop： 参考链接：</description>
    </item>
    <item>
      <title>React学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/react%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Wed, 17 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/react%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>新建项目 npx create-react-app appName node_modules：保存依赖的库 public：保存静态文件 manifest.json：记录app的元数据，如名字，主题，字体等 robots.txt：设置User-agent、Disallow和Allow，提供网络交互routing规则 src：源代码 index.js：app启动入口，连接到index.html的root节点 App.js：具体app逻辑，可以理解为html的index.html 语法为JSX（Javascript XML），将javascript和html结合 采用function component，即App这个函数，返回一个“动态的html” export default，外部可以复用 App.test.js：测试文件 reportWebVitals.js：性能测试文件 package.json：记录关键信息，例如依赖、版本、启动脚本等 package-lock.json：记录依赖版本，保证协同开发版本一致 参考链接：&#xA;# Master React JS in easy way 基本概念 Components 只返回一个元素：需要把要返回的部分包起来，比如&lt;div&gt;或者空的&lt;&gt; mount指添加组件到DOM，unmount指从DOM移除组件 props：用来给Component返回的元素加入属性，来实现不同的具体内容 component中： function Greeting(props) { return &lt;h1&gt;{props.text}&lt;/h1&gt; } 使用中： &lt;Greeting text={&#39;yo&#39;}/&gt; key props：用于区分component，可以用数字或str，一般在map函数中使用： {items.map((item =&gt; ( &lt;Component key={item.id} /&gt; ))} propTypes：用来确保传入的prop的属性类型正确 array用PropTypes.arrayof object用PropTypes.shape({x: PropTypes.xxx, y: PropTypes.yyy}) Student.propTypes = { name: PropTypes.string, age: PropTypes.number, isStudent: PropTypes.bool, } defaultProp：用来填充prop的默认值 Rendering 利用虚拟DOM（VDOM）进行渲染：react做的三步 当state改变，更新VDOM 通过diffs检查改变 reconciliation：协调改变真实DOM Hook State hooks：useState/useReducer 记录状态，返回状态变量和更新函数 const [count, setCount] = useState(0) 实现受控组件（controlled components），提供数据驱动的能力，将UI和用户行为产生的数据关联在一起 function ControlledInput() { const [value, setValue] = useState(&#39;&#39;) return ( &lt;input value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt; ) } 与原生JS实现的区别：</description>
    </item>
    <item>
      <title>从零开始构建Tetris</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAtetris/index.html</link>
      <pubDate>Sun, 14 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAtetris/index.html</guid>
      <description>背景 在完成css、html、javascript的基础上，构建Tetris游戏，以巩固以上知识点 游戏布局 整体游戏布局分为两部分： 主画面：20 * 10 的grid sidebar：包含以下几部分： next：4 * 4 的grid提示下一个是什么 分数栏：包含当前分数和最高分数 按钮栏：包含暂停（pause）和开始（play） Game Loop 用户进入界面后，游戏状态为“ready” 点击play按钮开始Game Loop，游戏状态进入“play” 每50帧，block向下一格 如果向下位置已经有颜色，则锁住当前block的颜色，新建block，同时清理整行 如果当前block无法新建，即新建位置之前被填充颜色，则失败 游戏过程中点击pause按钮暂停Game Loop，暂停所有keydown事件监听，游戏状态进入“pause” 用户点击play按钮继续Game Loop，游戏状态进入“play” 游戏失败后，游戏状态变为“end”，弹出对话框，显示分数，play按钮文本变为replay 用户点击replay按钮重新初始化，开始Game Loop，游戏状态进入“play” 技术细节 Grid背景 主画面的20 * 10的grid的显示，需要在scene中新建200个div，且每个div之间有gap，scene本身的背景颜色设为深色，div的背景颜色设为白色，这样gap会显示为深色的线 #scene &gt; div { background-color: white; } #scene { display: grid; grid-template-columns: repeat(10, 1fr); grid-template-rows: repeat(20, 1fr); gap: 1px; background-color: #999; /* 网格线颜色 */ border: 3px solid blue; margin: 10px; position: relative; } 移动和旋转 游戏过程中只有一个block是active的，也就是用户控制的 block的状态包含形状（index）、旋转（四种方向）和位置 let blockState = { index: 0, rotation: 0, x: 1, y: 4, } 通过block的index以及x、y，结合旋转，可以确定整个block的所有div 每次旋转90度：[x, y] = [y, -x] const TETROMINOES = [ // I 块 (直线) [ [-1, 0], [0, 0], [1, 0], [2, 0] ], // O 块 (方形) [ [0, 0], [-1, 0], [-1, 1], [0, 1] ], // L 块 [ [-1, 0], [0, 0], [1, 0], [1, 1] ], // J 块 [ [-1, 0], [0, 0], [1, 0], [-1, 1] ], // T 块 [ [-1, 0], [0, 0], [1, 0], [0, 1] ], // S 块 [ [-1, 0], [0, 0], [0, 1], [1, 1] ], // Z 块 [ [0, 0], [1, 0], [-1, 1], [0, 1] ], ]; 当block在边缘处旋转时，有超出边框的可能，这时候需要向里移动一格 新建Block 新建Block的时候，需要将之前设定的nextBlockIndex作为新的blockIndex，同时随机产生一个新的nextBlockIndex，根据这两个index渲染next的grid和scene的grid 如果发现新建Block的div上已经填充颜色，说明scene满了，游戏失败，返回false，否则返回true；Game Loop里通过这个返回值跳出 // 七种模块在next中的index const nextBlockIndices = [ [2, 6, 10, 14], // I [5, 6, 9, 10], // O [1, 5, 9, 10], // L [1, 2, 5, 9], // J [1, 5, 6, 9], // T [1, 5, 6, 10], // S [2, 5, 6, 9], // Z ] function NewBlock() { blockIndex = nextBlockIndex; blockState = { index: blockIndex, rotation: 0, x: 1, y: 4, }; let newBlockIndices = GetBlockAllIndices(blockState); for (let [newX, newY] of newBlockIndices) { if (blockColors[newX][newY] != &#34;white&#34;) { return false; } } nextBlockIndex = Math.floor(Math.random() * 7); for (let i=0; i &lt; 16; i++) { if (nextBlockIndices[nextBlockIndex].includes(i)) { nextBlocks[i].style.background = index2Color[nextBlockIndex]; } else { nextBlocks[i].style.background = &#39;white&#39;; } } console.log(`NewBlock: ${blockIndex}, ${nextBlockIndex}`); return true; } Ghost Block 为提升用户体验，为当前block预期掉落位置Ghost Block加border，方便用户通过空格键快速掉落block // 画预期掉落block (Ghost Block) // 1. 计算能掉落多远 let moveX = 0; while (canMoveBlock(moveX + 1, 0)) { // 注意这里要探测 +1 的位置 moveX++; } // 2. 只有当能移动时才画 ghost if (moveX &gt; 0) { let dropBlockState = {...blockState}; dropBlockState.x += moveX; let dropBlockIndices = GetBlockAllIndices(dropBlockState); for (let [x, y] of dropBlockIndices) { let dropIndex = x * colNum + y; // 确保不覆盖已经存在的方块颜色（虽然 ghost 通常在空白处，但为了保险） if (blockColors[x][y] === &#39;white&#39;) { sceneBlocks[dropIndex].style.border = `1px dashed ${index2Color[blockState.index]}`; } } }</description>
    </item>
    <item>
      <title>CSS学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/css%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/css%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>基础用法 id：采用id的方式（比如&lt;p id=“p1”&gt;），可以用#（比如#p1） class：给元素在html里加上class，在css里面可以针对class加格式，比如.class combinators descendant：使用“ ”，对所有子节点加格式，比如.class p child：使用“&gt;” ，对儿子节点加格式（不包括孙子及更远下属） general sibling：使用“～”，兄弟节点 adjacent sibling：使用“+”，相邻兄弟节点 伪class：定义元素在特殊状态时的格式，比如： 悬浮：hover（li:hover，li:not(:hover)） 选中：active 某个：nth-child（li:nth-child(2)，li:nth-child(even)） 伪元素：对某一类元素加细粒度格式（比如p的第一行），可以用::（比如p::first-line、p::selection） span或者div（称为container）用来分组，从而对各组或整体进行排版 span是inline的，只对内容生效，div是block的，对整体block生效 通过nested layout技术组合横向或竖向（display设为block/inline-block）的div，得到几乎任意排版效果 box model：padding就是字和border的距离，margin就是border和其他元素的距离 position： static：元素原本位置，不受left、right、top、bottom影响，也不作为上级给absolute做基准定位 relative：元素原本位置加上left、right、top、bottom的影响，多用于flex的下级元素 fixed：基于窗口（即browser view）作为基准定位的位置 absolute：基于上级（如果没有上级，即page）作为基准定位的位置 sticky：跟着scroll走 z-index：在html中的出现顺序决定了元素的默认渲染顺序，即后出现的在上面。可以通过设置z-index解决谁覆盖谁的问题（越大越靠上） grid：可以实现行列m x n布局，m和n也可以根据页面大小自适应调整 flexbox：可以方便地对container内部的元素进行动态的水平和垂直布局 可以解决两个div之间由于html换行导致的空格间隙 相比grid先定义行列再填充内容的方式，flexbox根据内容自动调整行列大小 参考链接： # Learn Flexbox CSS in 8 minutes transform：可以使对象旋转、缩放、变形等，会使用gpu加速，做动画场景时优先考虑 aspect-ratio：保持元素的比例，例如16:9 @media：考虑显示器的大小，实现相对应的不同样式，比如横向排版在宽度变小后改为纵向排版 @keyframes：利用transform、opacity、background-color等实现简单的动画效果 var：变量，实现属性的重复使用。变量名一般在:root伪作用域中定义，以双破折号–开头，通过var()函数来引用定义的值 :root { --primary-color: #3498db; /* 蓝色 */ --font-size-base: 16px; } body { background-color: var(--primary-color); font-size: var(--font-size-base); } calc：可以结合变量进行赋值操作，如animation-delay: calc(var(X)) * 100ms;</description>
    </item>
    <item>
      <title>HTML学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/html%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/html%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>基础概念 HTML本质上 就是和markdown 一样的标记语言，用于给文本添加格式。&#xA;markdown的设计目标是对应markup做的简化版本&#xA;data-* ../Answers/HTML中的data-* Canvas canvas创建 &lt;canvas width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;/canvas&gt; context 设置使用2D canvas，获取canvas的context，后续操作都是通过context</description>
    </item>
    <item>
      <title>Javascript包管理</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/javascript%E5%8C%85%E7%AE%A1%E7%90%86/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/javascript%E5%8C%85%E7%AE%A1%E7%90%86/index.html</guid>
      <description>npm npm init在项目中来创建package.json –yes（-y）直接默认 package.json的作用： 管理项目依赖 scripts中支持脚本运行初始化构建项目 package-lock.json：由于不同时间npm install的包版本不一致，需要用这个文件来固定版本，保证不同人安装同样的版本 npm install安装依赖，创建node_modules目录存放 –save（-S）可以自动在package.json中记录 –save-dev（-D）表示只用于develop，不用于production -g：全局（global）安装，不会出现在package.json中，可以命令行执行，例如live-server @X.X.X：安装指定版本 ^X.X.X指保持大版本，小版本和patch更新到最新 ~X.X.X指保持大版本和小版本，patch更新到最新 *指更新到最新 npm list列出项目依赖 –depth 0，不显示子依赖，1，显示一级子依赖 –global true，显示全局安装 npm update更新依赖到指定的最新版本 npm prune删除package.json中不存在的已安装依赖 npm run运行package.json中scripts指定的命令 参考链接：&#xA;npm Tutorial for Beginners # NPM Full Course For Beginners - Learn NPM fundamentals and basics Yarn yarn add来安装包 yarn.lock对应package-lock.json的作用 yarn set version berry：设置为v2版本 v2版本支持pnp（plug and play）：Yarn 在您的本地文件系统上维护了一个全局缓存目录，所有通过 Yarn 下载的包都会被存储在这个目录中，且是zip压缩的，从而实现离线安装 参考链接：</description>
    </item>
    <item>
      <title>Javascript学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/javascript%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/javascript%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>基础用法 console.log：打印变量，可以在页面中inspect看到，或者使用node直接界面打印 对于多个{}的打印可以console.log({foo, bar, baz})可以看到每个map的名字 可以console.table来对结构化数据打印 console.time(XXX)和console.timeEnd(XXX)可以用来计时 console.trace可以追踪执行代码位置 ``：反引号表示模版字面量，类似formatted string 标签模版字面量：函数后面紧接着模版字面量 foo(strs, …values)，如foo`this is ${apple.id}`，strs接收被${}分开的部分，values接收${}的部分，从而自定义字符串解析和输出 可以作为DSL使用，如 ../Answers/标签模版字面量在DSL中的例子 ===：三个等号是全等，即对象类型和值均相等，两个等号只代表值相等 …：spread标识 可变参数，比如function foo (a, b, …c)，c获取剩余可变参数 将两个{}合并在一起，const ab = {…a, …b}; 给array添加元素，a = […a, “apple”, “banana”]; typeof：类型判断，如typeof xxx !== ‘function’ for循环： 对array（可迭代对象，包括map）可以用of for(ele of elements) {...} 对object属性可以用in for(property in element) {...} forEach函数接受的callback可以最多包含element、index、array三个参数 map函数相比forEach的区别：返回新的array；类似的还有filter reduce函数接受accumulator和element两个参数，最终返回一个element arrow function：一种函数定义的简化：() =&gt; … ()里面填参数，…填函数实现，多用于简单的one-liner fruits.forEach(fruit =&gt; console.log(fruit.calories)); this：使用当前对象作为this arrow function中的this的指向是代码位置确定的（词法定义域，Lexical Scope），而不是他被调用时确定的，因此在回调函数函数中可以绑定到当前对象（如果是普通函数作为回调函数，this在运行时才确定，已经和对象失联，只会绑定到global object） 可以用来实现constructor（ES6新特性支持class） super：使用父类方法 在子类中定义constructor时要首先使用父类的constructor，即super(xxx) setter和getter：用set和get关键字函数，定义class的私有属性的读写 外部只通过setter和getter读写私有属性，逻辑可控（比如类型检查） destructuring： 通过[]来解构array内容，例如swap a，b：[a,b] = [b,a] const elements = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]; // a = &#39;a&#39;, b = &#39;b&#39;, c = &#39;c&#39;, r = [&#39;d&#39;, &#39;e&#39;] const [a, b, c, ...r] = elements; 通过{}来解构object内容，可以在function的参数使用这个方式 function displayPerson({firstname, lastname}) { console.log(firstname); console.log(lastname); } sort：默认情况按lexicographic（字母+数字+符号）排序，即1、10、2、3… 可以添加cmp：numbers.sort((a,b) =&gt; a - b)，来进行数字排序 string属性不能用减法，转成NAN后都相等，需要a.name.localeCompare(b.name) shuffle：没有内置的shuffle，需要自己实现Fisher-Yates算法 setTimeout：等待一段时间（毫秒）后执行函数，可以通过clearTimeout取消 异常捕获： 使用try、catch、finally拦截异常 使用throw new Error()抛出异常 修改html： 添加三部曲：构建element、添加属性、插入DOM（基于父节点） 删除：removeChild，基于父节点 事件监听：eventListener 监听click、mouseover、mouseout、keydown、keyup事件 .addEventListener(event, callback) 可以通过DOMContentLoaded事件来等待dom加载完成后再加载图片 classList：通过api访问className，来修改元素的css类，相当于通过js给页面动态加样式 支持add、remove、toggle、replace、contains操作 JSON：stringify和parse实现js obect和json string的相互转换 fetch：异步函数，通过路径（本地或远程连接）读取数据 事件委托 ../Answers/Javascript中的事件委托 Module module：代码通过模块载入，类似python的import 在html的script标签里加上type=“module”，将index.js当作module载入 变量和函数前需要加上export关键字 在index.js头部加上import {变量名、函数名} from ‘文件路径’ 异步 setTimeout就是一个异步函数的例子，不阻碍主线程 一般通过callback、promise、async/await实现 当使用callback来串联异步函数时，会出现callback hell现象，即callback嵌套过度让代码可读性变差，可以通过promise或者async/await解决 promise：用来管理异步操作的对象 异步函数foo()返回promise对象，new Promise((resolve, reject)) =&gt; {异步逻辑} 用.then来承接异步函数，即foo().then(value =&gt; {…})，then里面写resolve处理逻辑 resolve函数可以返回另一个promise，用来串联下一个异步函数 用.catch来承接异步函数，即foo().catch(error =&gt; {…})，catch里面写reject处理逻辑 reject函数指定失败的逻辑，对整体异步链生效，无法针对其中的某个异步函数单独指定reject 如果想对某个异步函数实现单独失败处理，有如下两种方案： 方法一：.then中加入(error =&gt; {…})的部分 方法二：在异步函数中的reject参数中给出类型，在后续统一的catch中按类型实现单独逻辑 async/await：用同步的方式写异步 async让一个函数返回promise 是个语法糖，自动将函数返回结果包装在Promise.resolve()中 await让一个异步函数等待一个promise 通过写一个async关键词的函数来包含多个异步函数，每个异步函数用await来等待结果，用try/catch来捕获异步过程中的error，可以将上述promise的链式调用改写为同步风格的函数： function bar() { return new Promise((...)) } function fuz() { return new Promise((...)) } async function foo() { xxx = await bar(); yyy = await fuz(); } DOM的概念 DOM：Document Object Model 浏览器加载html构建DOM，将元素以树形结构展示 javascript可以通过DOM动态改变网页的内容、结构和样式 动态（live）获取，指查询后的改变能实时更新，类似于引用： getElementById：精准获取element getElementsClassName返回html collection，注意不等同于array，比如不支持forEach操作，可以用Array.from(XXX)来转化为array getElementsByTagName返回所有tag（如h2）下面的html collection 静态（static）获取，指查一次，子元素不再改变，类似于快照、拷贝： querySelector/querySelectorAll通过类似css的获取方式（./#） querySelector获取第一个element querySelectorAll获取nodelist，一般用forEach遍历 可以用console.dir(document)来显示结构 ES6新特性 let和const替代var： 明确的块级作用域， 避免变量提升（hoisting），鼓励先声明后使用 防止重复声明（var可以重复声明，后者覆盖前者） 引入const，var不具有const的属性 this：指向对象本身 只有在对象调用的时候才指向对象，否则指向global object（window） 可以通过bind将函数手动绑定到对象上来正确使用this 异步函数的回调函数中的this，不会自动绑定到对象上，需要使用arrow函数或者手动绑定 const person = { name: &#39;Alice&#39;, talk() { // 箭头函数继承了外部 talk() 的 this (即 person) setTimeout(() =&gt; { console.log(&#34;this&#34;, this); // 输出: person }, 1000); } }; person.talk(); 解构： 同名结构，如果需要重命名，可以 address = { &#34;a&#34;: 1, &#34;b&#34;: 2 } const {a: e, b: f} = address // 这样 e 的值才是 address.a (即 1) …： 可以展开array，例如a.concat(b)等价于[…a, …b]，展开object，例如{…a, …b} 同样的可以用来clone array class： 预留constructor关键字作为构造函数名，类似之前的首字母大写的同名函数 继承：class b extends a { … }，需要在constructor中调用super() module： 对外部需要调用的class/function加上export关键字 named：export class a { … } default：export default class a { … } 对内部需要使用的部分进行import， named：import { a } from ‘文件路径’ default：import a from ‘文件路径’ 命名（named）导出和默认（default）导出： 命名导出只能有一个，而命名导出可以多个，import a, { b, c, d } from ‘文件路径’ 在html文件中需要标记&lt;script type=‘module’ src=‘index.js’&gt;&lt;/script&gt; 面向对象 OOP的四大基本原则： encapsulation（封装）：对象的内部函数可以将属性用this关键词使用 abstraction（抽象）：定义接口，隐藏内部逻辑和变量 inheritance（继承）：减少重复代码 polymorphism（多态）：不同的子类对于相同函数签名的实现 构造函数： 函数名首字母大写，内部属性用this表示，隐式返回this 调用使用new关键字，否则当作普通函数对待 对象的属性可以随时增减，因为本质就是一个{} 可以用obj[‘xxx’] = yyy来新增属性（正常是obj.xxx = yyy），这样属性名可以不用写死 delete关键字删除属性 基本类型按值拷贝，对象（{}、函数、Array）按引用拷贝 函数内用let定义私有属性，防止外部使用 getter/setter： 通过Object.defineProperty来实现 Object.defineProperty(this, &#39;xxx&#39;, { get: function() { return xxx; }, set: function(value) { if (value is valid) xxx = value; } }) 或者直接定义set，get class Example { constructor(value) { this._value = value; // 约定：内部存储属性 } // 公共接口：控制对属性的访问 get value() { return this._value; } set value(newValue) { this._value = newValue; } } 扩展阅读 javascript游戏编程 Javascript Game Development Masterclass 2022</description>
    </item>
    <item>
      <title>游戏编程基本概念</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/index.html</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/index.html</guid>
      <description>Game Loop Game Loop的结构通常是以下三步的循环： Process Input Update Game State Draw Game 参考链接： Game Programming Patterns # Game States and Game Loops # Getting The Game Loop Right 扩展阅读</description>
    </item>
    <item>
      <title>从零开始构建Flappy Bird</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAflappy-bird/index.html</link>
      <pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAflappy-bird/index.html</guid>
      <description>背景 在完成css、html、javascript的基础上，构建Flappy Bird游戏，以巩固以上知识点 预备知识： HTML学习手册-Canvas 游戏编程基本概念-Game Loop 在线试玩 Flappy Bird Game Loop Flappy Bird的游戏逻辑设计 home：主页，显示标题和两个button（start、score），目前只实现了start ready：主页点击start进入ready页面，给出游戏提示“tap” play：在ready页面tap后进入游戏页面，包含： 初始化：小鸟、pipe和实时分数 监听用户tap： 没有tap的话有向下加速度，模拟重力 有tap行为则直接给一个向上的速度 记分：小鸟每次经过一个pipe，score加1，score超过best则覆盖best 结束：小鸟和pipe的碰撞检测，碰到上下边缘或者pipe则结束，进入结束页面 over： 结束页面显示记分牌，显示奖牌（是best则金牌，不然白牌），显示score和best 给出ok和menu按钮，其中ok回到ready页，menu回到home页 技术细节 精灵图集 Sprite 精灵图集将游戏中所有的小图片（如小鸟、管道、背景、按钮等）集中在一个大文件里 在网页中获取的时候，可以使用CSS Sprites技术：使用 background-image 和 background-position 两个属性来在网页元素中显示精灵图集上的某一个图标或图片 可以使用 Sprite Cow对精灵图集进行分割处理，得到每个图标的position 注意图标推荐放在div或者span中，而不是img中 如何实现游戏基本逻辑 利用requestAnimationFrame（简单来说，rAF告诉浏览器：“我要执行一个动画，请在下一次重绘（Repaint）之前调用我的回调函数。”），将Game Loop函数作为callback，从而不断刷新游戏状态，实现元素的移动，以及整体Game Loop function GameLoop() { //移动小鸟 ... // 更新游戏分数 updateGameScore(); // 更新pipes的状态 updatePipes(); // 边界碰撞检测 if (birdPosY &lt; 0 || birdPosY + 22 &gt; 400) { console.log(&#34;Hit Boundary&#34;); game_state = &#34;ended&#34;; } // pipe碰撞检测 ... if (game_state === &#34;ended&#34;) { ... console.log(&#34;Game Over!&#34;); return; } requestAnimationFrame(GameLoop); } 如何实现背景的移动 css中将背景设置为精灵图集中的一部分，且repeat-x，水平循环 #scene { position: relative; /* 改为相对定位，由 flex 控制居中 */ border: 5px solid red; box-sizing: border-box; /* 让 border 包含在宽高内 */ display: flex; align-items: center; justify-content: center; flex-direction: column; background: url(&#39;../images/flappy-bird-sprite.png&#39;) repeat-x 0 0; image-rendering: pixelated; width: 225px; /* 原始宽度 */ height: 400px; /* 原始高度 */ overflow: hidden; /* 确保内容不溢出游戏画面 */ } 在js中设置scene的backgroundPostion可以整体移动 scene.style.backgroundPosition = `-${backgroundX}px 0px`; 如何实现小鸟的移动 水平方向上不移动，固定在屏幕30%位置上 #bird { position: absolute; background: url(&#39;../images/flappy-bird-sprite.png&#39;) no-repeat -179px -513px; width: 28px; height: 22px; top: 200px; left: 30%; transform: translateX(-50%); } 垂直方向上，根据游戏逻辑，确定位置后，通过top来实现移动 // 重力加速度下降 birdSpeedY += 0.1; birdPosY = birdPosY + birdSpeedY; bird.style.top = `${birdPosY}px`; 如何实现小鸟扇动翅膀 对于小鸟这个div，根据时间不断切换精灵图集中的backgroundPosition，从而切换不同图片 // 小鸟扇翅膀动画 birdFrameTimer++; if (birdFrameTimer % birdWingRate === 0) { // 每10帧切换一次图片，数字越小越快 birdFrameIndex = (birdFrameIndex + 1) % birdFrames.length; bird.style.backgroundPosition = birdFrames[birdFrameIndex]; if (birdFrameTimer === birdWingRate) { birdFrameTimer = 0; } } 如何实现管道的平移 在html中写三组pipe元素 在js中通过transform水平移动，如果移动超过屏幕，则从最左侧重置到最右侧 // 如果移出屏幕左侧，移动到最右侧 if (pipe.x &lt; -pipeWidth) { // 找到当前最右边的管道的 x 坐标 let maxX = Math.max(...pipesData.map(p =&gt; p.x)); pipe.x = maxX + pipeDistance; // 重新随机高度 pipe.y = Math.floor(Math.random() * (300 - 100)) + 100; pipe.scored = false; } 如何实现页面切换 在html中写在一起 &lt;div id=&#34;scene&#34;&gt; &lt;!-- 首页场景 --&gt; &lt;div id=&#34;scene_home&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏准备场景 (默认隐藏) --&gt; &lt;div id=&#34;scene_ready&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏场景 (默认隐藏) --&gt; &lt;div id=&#34;scene_play&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏结束场景（默认隐藏）--&gt; &lt;div id=&#34;scene_over&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;/div&gt; 然后通过在js中设定某一个部分（div）的display是否为none，来切换显示不同部分 document.getElementById(&#34;ok_button&#34;).addEventListener(&#39;click&#39;, function(){ // 隐藏首页场景 document.getElementById(&#34;scene_over&#34;).style.display = &#39;none&#39;; // 隐藏游戏层 document.getElementById(&#34;scene_play&#34;).style.display = &#39;none&#39;; // 显示游戏场景 document.getElementById(&#34;scene_ready&#34;).style.display = &#39;flex&#39;; // 游戏状态进入ready game_state = &#34;ready&#34;; }); 代码仓库 github链接： flappy-bird</description>
    </item>
    <item>
      <title>Lua学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/lua%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Sat, 29 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/lua%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>参考链接：&#xA;Learn X in Y minutes # Lua, the simplest language to learn</description>
    </item>
    <item>
      <title>Python项目管理</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/python%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/index.html</link>
      <pubDate>Fri, 28 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/python%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/index.html</guid>
      <description>pip 一般通过freeze的命令记录目前全部环境依赖&#xA;pip freeze &gt; requirements.txt 其他人可以通过pip的方式一键安装全部环境以来&#xA;pip install -r requirements.txt 缺陷 pip install会将库安装到全局目录，多用户共享，导致版本依赖和兼容性问题 pip freeze的问题在于无法明确区分哪些是项目的直接依赖，只是一股脑的记录 pip uninstall后，对应的间接依赖不会被卸载掉 venv 在项目目录里执行，创建.venv虚拟python环境，名称推荐叫.venv，因为vscode等可以自动识别&#xA;python3 -m venv .venv 通过active激活环境，并通过deactivate关闭环境&#xA;// 激活环境 source .venv/bin/activate // 关闭环境 deactivate pyproject.toml 目标就是统一不同的配置文件，把所有与项目构建（打包、依赖管理）和工具配置相关的设置都放在这一个文件里</description>
    </item>
    <item>
      <title>OSI模型</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/osi%E6%A8%A1%E5%9E%8B/index.html</link>
      <pubDate>Sat, 15 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/osi%E6%A8%A1%E5%9E%8B/index.html</guid>
      <description>OSI模型是计算机通信网络的抽象模型</description>
    </item>
  </channel>
</rss>
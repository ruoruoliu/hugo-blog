<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术笔记 :: Tag :: Ruoruoliu 2.0</title>
    <link>https://ruoruoliu.github.io/hugo-blog/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/index.html</link>
    <description></description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 12 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ruoruoliu.github.io/hugo-blog/tags/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>HTML学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/html%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/html%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>Canvas canvas创建 &lt;canvas width=&#34;300&#34; height=&#34;200&#34;&gt;&lt;/canvas&gt; context 设置使用2D canvas，获取canvas的context，后续操作都是通过context&#xA;const ctx = canvas.getContext(&#34;2d&#34;); 绘制API 矩形 ctx.fillRect(x, y, width, height); 直线 ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke(); 图像 参数包括（可以分别选择前3、5、9个参数）： image、paste坐标（x1、y1）、paste大小（w1、h1）、原图坐标（x2、y2）、原图大小（w2、h2）</description>
    </item>
    <item>
      <title>Javascript学习手册</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/javascript%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/javascript%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/index.html</guid>
      <description>包管理 npm npm init在项目中来创建package.json –yes（-y）直接默认 package.json的作用： 管理项目依赖 scripts中支持脚本运行初始化构建项目 package-lock.json：由于不同时间npm install的包版本不一致，需要用这个文件来固定版本，保证不同人安装同样的版本 npm install安装依赖，创建node_modules目录存放 –save（-S）可以自动在package.json中记录 –save-dev（-D）表示只用于develop，不用于production -g：全局（global）安装，不会出现在package.json中，可以命令行执行，例如live-server @X.X.X：安装指定版本 ^X.X.X指保持大版本，小版本和patch更新到最新 ~X.X.X指保持大版本和小版本，patch更新到最新 *指更新到最新 npm list列出项目依赖 –depth 0，不显示子依赖，1，显示一级子依赖 –global true，显示全局安装 npm update更新依赖到指定的最新版本 npm prune删除package.json中不存在的已安装依赖 npm run运行package.json中scripts指定的命令 参考链接： npm Tutorial for Beginners # NPM Full Course For Beginners - Learn NPM fundamentals and basics 扩展阅读 javascript游戏编程 Javascript Game Development Masterclass 2022</description>
    </item>
    <item>
      <title>像素工具Asperite</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/asperite/index.html</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/asperite/index.html</guid>
      <description>官网链接</description>
    </item>
    <item>
      <title>游戏编程基本概念</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/index.html</link>
      <pubDate>Wed, 10 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/index.html</guid>
      <description>Game Loop Game Loop的结构通常是以下三步的循环： Process Input Update Game State Draw Game 参考链接： Game Programming Patterns # Game States and Game Loops # Getting The Game Loop Right 扩展阅读</description>
    </item>
    <item>
      <title>从零开始构建Flappy Bird</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAflappy-bird/index.html</link>
      <pubDate>Mon, 08 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BAflappy-bird/index.html</guid>
      <description>背景 在完成css、html、javascript的基础上，构建Flappy Bird游戏，以巩固以上知识点 预备知识： Canvas [[HTML学习手册#Canvas|HTML学习手册-Canvas]] Game Loop 在线玩Flappy Bird&#xA;Game Loop Flappy Bird的游戏逻辑设计 home：主页，显示标题和两个button（start、score），目前只实现了start ready：主页点击start进入ready页面，给出游戏提示“tap” play：在ready页面tap后进入游戏页面，包含： 初始化：小鸟、pipe和实时分数 监听用户tap： 没有tap的话有向下加速度，模拟重力 有tap行为则直接给一个向上的速度 记分：小鸟每次经过一个pipe，score加1，score超过best则覆盖best 结束：小鸟和pipe的碰撞检测，碰到上下边缘或者pipe则结束，进入结束页面 over： 结束页面显示记分牌，显示奖牌（是best则金牌，不然白牌），显示score和best 给出ok和menu按钮，其中ok回到ready页，menu回到home页 技术细节 精灵图集 Sprite 精灵图集将游戏中所有的小图片（如小鸟、管道、背景、按钮等）集中在一个大文件里 在网页中获取的时候，可以使用CSS Sprites技术：使用 background-image 和 background-position 两个属性来在网页元素中显示精灵图集上的某一个图标或图片 可以使用 Sprite Cow对精灵图集进行分割处理，得到每个图标的position 注意图标推荐放在div或者span中，而不是img中 如何实现游戏基本逻辑 利用requestAnimationFrame（简单来说，rAF告诉浏览器：“我要执行一个动画，请在下一次重绘（Repaint）之前调用我的回调函数。”），将Game Loop函数作为callback，从而不断刷新游戏状态，实现元素的移动，以及整体Game Loop function GameLoop() { //移动小鸟 ... // 更新游戏分数 updateGameScore(); // 更新pipes的状态 updatePipes(); // 边界碰撞检测 if (birdPosY &lt; 0 || birdPosY + 22 &gt; 400) { console.log(&#34;Hit Boundary&#34;); game_state = &#34;ended&#34;; } // pipe碰撞检测 ... if (game_state === &#34;ended&#34;) { ... console.log(&#34;Game Over!&#34;); return; } requestAnimationFrame(GameLoop); } 如何实现背景的移动 css中将背景设置为精灵图集中的一部分，且repeat-x，水平循环 #scene { position: relative; /* 改为相对定位，由 flex 控制居中 */ border: 5px solid red; box-sizing: border-box; /* 让 border 包含在宽高内 */ display: flex; align-items: center; justify-content: center; flex-direction: column; background: url(&#39;../images/flappy-bird-sprite.png&#39;) repeat-x 0 0; image-rendering: pixelated; width: 225px; /* 原始宽度 */ height: 400px; /* 原始高度 */ overflow: hidden; /* 确保内容不溢出游戏画面 */ } 在js中设置scene的backgroundPostion可以整体移动 scene.style.backgroundPosition = `-${backgroundX}px 0px`; 如何实现小鸟的移动 水平方向上不移动，固定在屏幕30%位置上 #bird { position: absolute; background: url(&#39;../images/flappy-bird-sprite.png&#39;) no-repeat -179px -513px; width: 28px; height: 22px; top: 200px; left: 30%; transform: translateX(-50%); } 垂直方向上，根据游戏逻辑，确定位置后，通过top来实现移动 // 重力加速度下降 birdSpeedY += 0.1; birdPosY = birdPosY + birdSpeedY; bird.style.top = `${birdPosY}px`; 如何实现小鸟扇动翅膀 对于小鸟这个div，根据时间不断切换精灵图集中的backgroundPosition，从而切换不同图片 // 小鸟扇翅膀动画 birdFrameTimer++; if (birdFrameTimer % birdWingRate === 0) { // 每10帧切换一次图片，数字越小越快 birdFrameIndex = (birdFrameIndex + 1) % birdFrames.length; bird.style.backgroundPosition = birdFrames[birdFrameIndex]; if (birdFrameTimer === birdWingRate) { birdFrameTimer = 0; } } 如何实现管道的平移 在html中写三组pipe元素 在js中通过transform水平移动，如果移动超过屏幕，则从最左侧重置到最右侧 // 如果移出屏幕左侧，移动到最右侧 if (pipe.x &lt; -pipeWidth) { // 找到当前最右边的管道的 x 坐标 let maxX = Math.max(...pipesData.map(p =&gt; p.x)); pipe.x = maxX + pipeDistance; // 重新随机高度 pipe.y = Math.floor(Math.random() * (300 - 100)) + 100; pipe.scored = false; } 如何实现页面切换 在html中写在一起 &lt;div id=&#34;scene&#34;&gt; &lt;!-- 首页场景 --&gt; &lt;div id=&#34;scene_home&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏准备场景 (默认隐藏) --&gt; &lt;div id=&#34;scene_ready&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏场景 (默认隐藏) --&gt; &lt;div id=&#34;scene_play&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;!-- 游戏结束场景（默认隐藏）--&gt; &lt;div id=&#34;scene_over&#34; style=&#34;display: none;&#34;&gt; ... &lt;/div&gt; &lt;/div&gt; 然后通过在js中设定某一个部分（div）的display是否为none，来切换显示不同部分 document.getElementById(&#34;ok_button&#34;).addEventListener(&#39;click&#39;, function(){ // 隐藏首页场景 document.getElementById(&#34;scene_over&#34;).style.display = &#39;none&#39;; // 隐藏游戏层 document.getElementById(&#34;scene_play&#34;).style.display = &#39;none&#39;; // 显示游戏场景 document.getElementById(&#34;scene_ready&#34;).style.display = &#39;flex&#39;; // 游戏状态进入ready game_state = &#34;ready&#34;; }); 代码仓库 github链接： flappy-bird</description>
    </item>
    <item>
      <title>Agent</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/agent/index.html</link>
      <pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/agent/index.html</guid>
      <description></description>
    </item>
    <item>
      <title>OSI模型</title>
      <link>https://ruoruoliu.github.io/hugo-blog/blogs/techs/osi%E6%A8%A1%E5%9E%8B/index.html</link>
      <pubDate>Sat, 15 Nov 2025 00:00:00 +0000</pubDate>
      <guid>https://ruoruoliu.github.io/hugo-blog/blogs/techs/osi%E6%A8%A1%E5%9E%8B/index.html</guid>
      <description>OSI模型是计算机通信网络的抽象模型</description>
    </item>
  </channel>
</rss>